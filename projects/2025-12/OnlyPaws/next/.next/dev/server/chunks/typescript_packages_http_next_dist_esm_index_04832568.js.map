{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/http/next/src/index.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/http/next/src/utils.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/http/next/src/adapter.ts"],"sourcesContent":["import {\n  PaywallConfig,\n  PaywallProvider,\n  x402ResourceServer,\n  RoutesConfig,\n  RouteConfig,\n  FacilitatorClient,\n} from \"@x402/core/server\";\nimport { SchemeNetworkServer, Network } from \"@x402/core/types\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport {\n  createHttpServer,\n  createRequestContext,\n  handlePaymentError,\n  handleSettlement,\n} from \"./utils\";\n\n/**\n * Configuration for registering a payment scheme with a specific network\n */\nexport interface SchemeRegistration {\n  /**\n   * The network identifier (e.g., 'eip155:84532', 'solana:mainnet')\n   */\n  network: Network;\n\n  /**\n   * The scheme server implementation for this network\n   */\n  server: SchemeNetworkServer;\n}\n\n/**\n * Next.js payment proxy for x402 protocol (direct server instance).\n *\n * Use this when you want to pass a pre-configured x402ResourceServer instance.\n * This provides more flexibility for testing, custom configuration, and reusing\n * server instances across multiple proxies.\n *\n * @param routes - Route configurations for protected endpoints\n * @param server - Pre-configured x402ResourceServer instance\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Next.js proxy handler\n *\n * @example\n * ```typescript\n * import { paymentProxy } from \"@x402/next\";\n * import { x402ResourceServer } from \"@x402/core/server\";\n * import { registerExactEvmScheme } from \"@x402/evm/exact/server\";\n *\n * const server = new x402ResourceServer(myFacilitatorClient);\n * registerExactEvmScheme(server, {});\n *\n * export const proxy = paymentProxy(routes, server, paywallConfig);\n * ```\n */\nexport function paymentProxy(\n  routes: RoutesConfig,\n  server: x402ResourceServer,\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  const { httpServer, init } = createHttpServer(routes, server, paywall, syncFacilitatorOnStart);\n\n  // Dynamically register bazaar extension if routes declare it\n  let bazaarPromise: Promise<void> | null = null;\n  if (checkIfBazaarNeeded(routes)) {\n    bazaarPromise = import(/* webpackIgnore: true */ \"@x402/extensions/bazaar\")\n      .then(({ bazaarResourceServerExtension }) => {\n        server.registerExtension(bazaarResourceServerExtension);\n      })\n      .catch(err => {\n        console.error(\"Failed to load bazaar extension:\", err);\n      });\n  }\n\n  return async (req: NextRequest) => {\n    const context = createRequestContext(req);\n\n    // Check if route requires payment before initializing facilitator\n    if (!httpServer.requiresPayment(context)) {\n      return NextResponse.next();\n    }\n\n    // Only initialize when processing a protected route\n    await init();\n\n    // Await bazaar extension loading if needed\n    if (bazaarPromise) {\n      await bazaarPromise;\n      bazaarPromise = null;\n    }\n\n    // Process payment requirement check\n    const result = await httpServer.processHTTPRequest(context, paywallConfig);\n\n    // Handle the different result types\n    switch (result.type) {\n      case \"no-payment-required\":\n        // No payment needed, proceed directly to the route handler\n        return NextResponse.next();\n\n      case \"payment-error\":\n        return handlePaymentError(result.response);\n\n      case \"payment-verified\": {\n        // Payment is valid, need to wrap response for settlement\n        const { paymentPayload, paymentRequirements } = result;\n\n        // Proceed to the next proxy or route handler\n        const nextResponse = NextResponse.next();\n        return handleSettlement(httpServer, nextResponse, paymentPayload, paymentRequirements);\n      }\n    }\n  };\n}\n\n/**\n * Next.js payment proxy for x402 protocol (configuration-based).\n *\n * Use this when you want to quickly set up proxy with simple configuration.\n * This function creates and configures the x402ResourceServer internally.\n *\n * @param routes - Route configurations for protected endpoints\n * @param facilitatorClients - Optional facilitator client(s) for payment processing\n * @param schemes - Optional array of scheme registrations for server-side payment processing\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns Next.js proxy handler\n *\n * @example\n * ```typescript\n * import { paymentProxyFromConfig } from \"@x402/next\";\n *\n * export const proxy = paymentProxyFromConfig(\n *   routes,\n *   myFacilitatorClient,\n *   [{ network: \"eip155:8453\", server: evmSchemeServer }],\n *   paywallConfig\n * );\n * ```\n */\nexport function paymentProxyFromConfig(\n  routes: RoutesConfig,\n  facilitatorClients?: FacilitatorClient | FacilitatorClient[],\n  schemes?: SchemeRegistration[],\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n) {\n  const ResourceServer = new x402ResourceServer(facilitatorClients);\n\n  if (schemes) {\n    schemes.forEach(({ network, server: schemeServer }) => {\n      ResourceServer.register(network, schemeServer);\n    });\n  }\n\n  // Use the direct paymentProxy with the configured server\n  // Note: paymentProxy handles dynamic bazaar registration\n  return paymentProxy(routes, ResourceServer, paywallConfig, paywall, syncFacilitatorOnStart);\n}\n\n/**\n * Wraps a Next.js App Router API route handler with x402 payment protection.\n *\n * Unlike `paymentProxy` which works as middleware, `withX402` wraps individual route handlers\n * and guarantees that payment settlement only occurs after the handler returns a successful\n * response (status < 400). This provides more precise control over when payments are settled.\n *\n * @param routeHandler - The API route handler function to wrap\n * @param routeConfig - Payment configuration for this specific route\n * @param server - Pre-configured x402ResourceServer instance\n * @param paywallConfig - Optional configuration for the built-in paywall UI\n * @param paywall - Optional custom paywall provider (overrides default)\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on startup (defaults to true)\n * @returns A wrapped Next.js route handler\n *\n * @example\n * ```typescript\n * import { NextRequest, NextResponse } from \"next/server\";\n * import { withX402 } from \"@x402/next\";\n * import { x402ResourceServer } from \"@x402/core/server\";\n * import { registerExactEvmScheme } from \"@x402/evm/exact/server\";\n *\n * const server = new x402ResourceServer(myFacilitatorClient);\n * registerExactEvmScheme(server, {});\n *\n * const handler = async (request: NextRequest) => {\n *   return NextResponse.json({ data: \"protected content\" });\n * };\n *\n * export const GET = withX402(\n *   handler,\n *   {\n *     accepts: {\n *       scheme: \"exact\",\n *       payTo: \"0x123...\",\n *       price: \"$0.01\",\n *       network: \"eip155:84532\",\n *     },\n *     description: \"Access to protected API\",\n *   },\n *   server,\n * );\n * ```\n */\nexport function withX402<T = unknown>(\n  routeHandler: (request: NextRequest) => Promise<NextResponse<T>>,\n  routeConfig: RouteConfig,\n  server: x402ResourceServer,\n  paywallConfig?: PaywallConfig,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n): (request: NextRequest) => Promise<NextResponse<T>> {\n  const routes = { \"*\": routeConfig };\n  const { httpServer, init } = createHttpServer(routes, server, paywall, syncFacilitatorOnStart);\n\n  // Dynamically register bazaar extension if route declares it\n  let bazaarPromise: Promise<void> | null = null;\n  if (checkIfBazaarNeeded(routes)) {\n    bazaarPromise = import(/* webpackIgnore: true */ \"@x402/extensions/bazaar\")\n      .then(({ bazaarResourceServerExtension }) => {\n        server.registerExtension(bazaarResourceServerExtension);\n      })\n      .catch(err => {\n        console.error(\"Failed to load bazaar extension:\", err);\n      });\n  }\n\n  return async (request: NextRequest): Promise<NextResponse<T>> => {\n    await init();\n\n    // Await bazaar extension loading if needed\n    if (bazaarPromise) {\n      await bazaarPromise;\n      bazaarPromise = null;\n    }\n\n    const context = createRequestContext(request);\n\n    // Process payment requirement check\n    const result = await httpServer.processHTTPRequest(context, paywallConfig);\n\n    // Handle the different result types\n    switch (result.type) {\n      case \"no-payment-required\":\n        // No payment needed, proceed directly to the route handler\n        return routeHandler(request);\n\n      case \"payment-error\":\n        return handlePaymentError(result.response) as NextResponse<T>;\n\n      case \"payment-verified\": {\n        // Payment is valid, need to wrap response for settlement\n        const { paymentPayload, paymentRequirements } = result;\n        const handlerResponse = await routeHandler(request);\n        return handleSettlement(\n          httpServer,\n          handlerResponse,\n          paymentPayload,\n          paymentRequirements,\n        ) as Promise<NextResponse<T>>;\n      }\n    }\n  };\n}\n\n/**\n * Check if any routes in the configuration declare bazaar extensions\n *\n * @param routes - Route configuration\n * @returns True if any route has extensions.bazaar defined\n */\nfunction checkIfBazaarNeeded(routes: RoutesConfig): boolean {\n  // Handle single route config\n  if (\"accepts\" in routes) {\n    return !!(routes.extensions && \"bazaar\" in routes.extensions);\n  }\n\n  // Handle multiple routes\n  return Object.values(routes).some(routeConfig => {\n    return !!(routeConfig.extensions && \"bazaar\" in routeConfig.extensions);\n  });\n}\n\nexport type {\n  PaymentRequired,\n  PaymentRequirements,\n  PaymentPayload,\n  Network,\n  SchemeNetworkServer,\n} from \"@x402/core/types\";\n\nexport type { PaywallProvider, PaywallConfig, RouteConfig } from \"@x402/core/server\";\n\nexport { RouteConfigurationError } from \"@x402/core/server\";\n\nexport type { RouteValidationError } from \"@x402/core/server\";\n\nexport { NextAdapter } from \"./adapter\";\n","import { NextRequest, NextResponse } from \"next/server\";\nimport {\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  PaywallProvider,\n  x402HTTPResourceServer,\n  x402ResourceServer,\n  RoutesConfig,\n} from \"@x402/core/server\";\nimport { PaymentPayload, PaymentRequirements } from \"@x402/core/types\";\nimport { NextAdapter } from \"./adapter\";\n\n/**\n * Result of createHttpServer\n */\nexport interface HttpServerInstance {\n  httpServer: x402HTTPResourceServer;\n  init: () => Promise<void>;\n}\n\n/**\n * Creates and configures the x402 HTTP server with initialization logic\n *\n * @param routes - The route configuration for the server\n * @param server - The x402 resource server instance\n * @param paywall - Optional paywall provider for custom payment UI\n * @param syncFacilitatorOnStart - Whether to sync with the facilitator on start (defaults to true)\n * @returns The HTTP server instance with initialization function\n */\nexport function createHttpServer(\n  routes: RoutesConfig,\n  server: x402ResourceServer,\n  paywall?: PaywallProvider,\n  syncFacilitatorOnStart: boolean = true,\n): HttpServerInstance {\n  // Create the x402 HTTP server instance with the resource server\n  const httpServer = new x402HTTPResourceServer(server, routes);\n\n  // Register custom paywall provider if provided\n  if (paywall) {\n    httpServer.registerPaywallProvider(paywall);\n  }\n\n  // Store initialization promise (not the result)\n  // httpServer.initialize() fetches facilitator support and validates routes\n  let initPromise: Promise<void> | null = syncFacilitatorOnStart ? httpServer.initialize() : null;\n\n  return {\n    httpServer,\n    async init() {\n      // Ensure initialization completes before processing\n      if (initPromise) {\n        await initPromise;\n        initPromise = null; // Clear after first await\n      }\n    },\n  };\n}\n\n/**\n * Creates HTTP request context from a Next.js request\n *\n * @param request - The Next.js request object\n * @returns The HTTP request context for x402 processing\n */\nexport function createRequestContext(request: NextRequest): HTTPRequestContext {\n  // Create adapter and context\n  const adapter = new NextAdapter(request);\n  return {\n    adapter,\n    path: request.nextUrl.pathname,\n    method: request.method,\n    paymentHeader: adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"x-payment\"),\n  };\n}\n\n/**\n * Handles payment error result by creating a 402 response\n *\n * @param response - The HTTP response instructions from payment verification\n * @returns A Next.js response with the appropriate 402 status and headers\n */\nexport function handlePaymentError(response: HTTPResponseInstructions): NextResponse {\n  // Payment required but not provided or invalid\n  const headers = new Headers(response.headers);\n  if (response.isHtml) {\n    headers.set(\"Content-Type\", \"text/html\");\n    return new NextResponse(response.body as string, {\n      status: response.status,\n      headers,\n    });\n  }\n  headers.set(\"Content-Type\", \"application/json\");\n  return new NextResponse(JSON.stringify(response.body || {}), {\n    status: response.status,\n    headers,\n  });\n}\n\n/**\n * Handles settlement after a successful response\n *\n * @param httpServer - The x402 HTTP resource server instance\n * @param response - The Next.js response from the protected route\n * @param paymentPayload - The payment payload from the client\n * @param paymentRequirements - The payment requirements for the route\n * @returns The response with settlement headers or an error response if settlement fails\n */\nexport async function handleSettlement(\n  httpServer: x402HTTPResourceServer,\n  response: NextResponse,\n  paymentPayload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<NextResponse> {\n  // If the response from the protected route is >= 400, do not settle payment\n  if (response.status >= 400) {\n    return response;\n  }\n\n  try {\n    const result = await httpServer.processSettlement(paymentPayload, paymentRequirements);\n\n    if (!result.success) {\n      // Settlement failed - do not return the protected resource\n      return new NextResponse(\n        JSON.stringify({\n          error: \"Settlement failed\",\n          details: result.errorReason,\n        }),\n        {\n          status: 402,\n          headers: { \"Content-Type\": \"application/json\" },\n        },\n      );\n    }\n\n    // Settlement succeeded - add headers and return original response\n    Object.entries(result.headers).forEach(([key, value]) => {\n      response.headers.set(key, value);\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"Settlement failed:\", error);\n    // If settlement fails, return an error response\n    return new NextResponse(\n      JSON.stringify({\n        error: \"Settlement failed\",\n        details: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 402,\n        headers: { \"Content-Type\": \"application/json\" },\n      },\n    );\n  }\n}\n","import { HTTPAdapter } from \"@x402/core/server\";\nimport { NextRequest } from \"next/server\";\n\n/**\n * Next.js adapter implementation\n */\nexport class NextAdapter implements HTTPAdapter {\n  /**\n   * Creates a new NextAdapter instance.\n   *\n   * @param req - The Next.js request object\n   */\n  constructor(private req: NextRequest) {}\n\n  /**\n   * Gets a header value from the request.\n   *\n   * @param name - The header name\n   * @returns The header value or undefined\n   */\n  getHeader(name: string): string | undefined {\n    return this.req.headers.get(name) || undefined;\n  }\n\n  /**\n   * Gets the HTTP method of the request.\n   *\n   * @returns The HTTP method\n   */\n  getMethod(): string {\n    return this.req.method;\n  }\n\n  /**\n   * Gets the path of the request.\n   *\n   * @returns The request path\n   */\n  getPath(): string {\n    return this.req.nextUrl.pathname;\n  }\n\n  /**\n   * Gets the full URL of the request.\n   *\n   * @returns The full request URL\n   */\n  getUrl(): string {\n    return this.req.url;\n  }\n\n  /**\n   * Gets the Accept header from the request.\n   *\n   * @returns The Accept header value or empty string\n   */\n  getAcceptHeader(): string {\n    return this.req.headers.get(\"Accept\") || \"\";\n  }\n\n  /**\n   * Gets the User-Agent header from the request.\n   *\n   * @returns The User-Agent header value or empty string\n   */\n  getUserAgent(): string {\n    return this.req.headers.get(\"User-Agent\") || \"\";\n  }\n\n  /**\n   * Gets all query parameters from the request URL.\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams(): Record<string, string | string[]> {\n    const params: Record<string, string | string[]> = {};\n    this.req.nextUrl.searchParams.forEach((value, key) => {\n      const existing = params[key];\n      if (existing) {\n        if (Array.isArray(existing)) {\n          existing.push(value);\n        } else {\n          params[key] = [existing, value];\n        }\n      } else {\n        params[key] = value;\n      }\n    });\n    return params;\n  }\n\n  /**\n   * Gets a specific query parameter by name.\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam(name: string): string | string[] | undefined {\n    const all = this.req.nextUrl.searchParams.getAll(name);\n    if (all.length === 0) return undefined;\n    if (all.length === 1) return all[0];\n    return all;\n  }\n\n  /**\n   * Gets the parsed request body.\n   *\n   * @returns Promise resolving to the parsed request body\n   */\n  async getBody(): Promise<unknown> {\n    try {\n      return await this.req.json();\n    } catch {\n      return undefined;\n    }\n  }\n}\n"],"names":["x402ResourceServer","NextResponse","NextResponse","x402ResourceServer"],"mappings":"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"}}]
}