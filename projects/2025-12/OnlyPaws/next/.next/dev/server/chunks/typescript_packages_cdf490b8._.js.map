{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/index.ts"],"sourcesContent":["export const x402Version = 2;\n"],"names":[],"mappings":";;;;;AAAO,IAAM,cAAc"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/utils/index.ts"],"sourcesContent":["import { Network } from \"../types\";\n\n/**\n * Scheme data structure for facilitator storage\n */\nexport interface SchemeData<T> {\n  facilitator: T;\n  networks: Set<Network>;\n  pattern: Network;\n}\n\nexport const findSchemesByNetwork = <T>(\n  map: Map<string, Map<string, T>>,\n  network: Network,\n): Map<string, T> | undefined => {\n  // Direct match first\n  let implementationsByScheme = map.get(network);\n\n  if (!implementationsByScheme) {\n    // Try pattern matching for registered network patterns\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      // Convert the registered network pattern to a regex\n      // e.g., \"eip155:*\" becomes /^eip155:.*$/\n      const pattern = registeredNetworkPattern\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape special regex chars except *\n        .replace(/\\\\\\*/g, \".*\"); // Replace escaped * with .*\n\n      const regex = new RegExp(`^${pattern}$`);\n\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n\n  return implementationsByScheme;\n};\n\nexport const findByNetworkAndScheme = <T>(\n  map: Map<string, Map<string, T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\n\n/**\n * Finds a facilitator by scheme and network using pattern matching.\n * Works with new SchemeData storage structure.\n *\n * @param schemeMap - Map of scheme names to SchemeData\n * @param scheme - The scheme to find\n * @param network - The network to match against\n * @returns The facilitator if found, undefined otherwise\n */\nexport const findFacilitatorBySchemeAndNetwork = <T>(\n  schemeMap: Map<string, SchemeData<T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return undefined;\n\n  // Check if network is in the stored networks set\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n\n  // Try pattern matching\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n\n  return undefined;\n};\n\nexport const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n/**\n * Deep equality comparison for payment requirements\n * Uses a normalized JSON.stringify for consistent comparison\n *\n * @param obj1 - First object to compare\n * @param obj2 - Second object to compare\n * @returns True if objects are deeply equal\n */\nexport function deepEqual(obj1: unknown, obj2: unknown): boolean {\n  // Normalize and stringify both objects for comparison\n  // This handles nested objects, arrays, and different property orders\n  const normalize = (obj: unknown): string => {\n    // Handle primitives and null/undefined\n    if (obj === null || obj === undefined) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(item =>\n          typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item,\n        ),\n      );\n    }\n\n    // Handle objects - sort keys and recursively normalize values\n    const sorted: Record<string, unknown> = {};\n    Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .forEach(key => {\n        const value = (obj as Record<string, unknown>)[key];\n        sorted[key] =\n          typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n      });\n    return JSON.stringify(sorted);\n  };\n\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    // Fallback to simple comparison if normalization fails\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAWO,IAAM,uBAAuB,CAClC,KACA,YAC+B;IAE/B,IAAI,0BAA0B,IAAI,GAAA,CAAI,OAAO;IAE7C,IAAI,CAAC,yBAAyB;QAE5B,KAAA,MAAW,CAAC,0BAA0B,eAAe,CAAA,IAAK,IAAI,OAAA,CAAQ,EAAG;YAGvE,MAAM,UAAU,yBACb,OAAA,CAAQ,uBAAuB,MAAM,EACrC,OAAA,CAAQ,SAAS,IAAI;YAExB,MAAM,QAAQ,IAAI,OAAO,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAG;YAEvC,IAAI,MAAM,IAAA,CAAK,OAAO,GAAG;gBACvB,0BAA0B;gBAC1B;YACF;QACF;IACF;IAEA,OAAO;AACT;AAEO,IAAM,yBAAyB,CACpC,KACA,QACA,YACkB;IAClB,OAAO,qBAAqB,KAAK,OAAO,GAAG,IAAI,MAAM;AACvD;AAWO,IAAM,oCAAoC,CAC/C,WACA,QACA,YACkB;IAClB,MAAM,aAAa,UAAU,GAAA,CAAI,MAAM;IACvC,IAAI,CAAC,WAAY,CAAA,OAAO,KAAA;IAGxB,IAAI,WAAW,QAAA,CAAS,GAAA,CAAI,OAAO,GAAG;QACpC,OAAO,WAAW,WAAA;IACpB;IAGA,MAAM,eAAe,IAAI,OAAO,MAAM,WAAW,OAAA,CAAQ,OAAA,CAAQ,KAAK,IAAI,IAAI,GAAG;IACjF,IAAI,aAAa,IAAA,CAAK,OAAO,GAAG;QAC9B,OAAO,WAAW,WAAA;IACpB;IAEA,OAAO,KAAA;AACT;AAEO,IAAM,qBAAqB;AAQ3B,SAAS,iBAAiB,IAAA,EAAsB;IACrD,IAAI,OAAO,eAAe,eAAe,OAAO,WAAW,IAAA,KAAS,YAAY;QAC9E,OAAO,WAAW,IAAA,CAAK,IAAI;IAC7B;IACA,OAAO,OAAO,IAAA,CAAK,IAAI,EAAE,QAAA,CAAS,QAAQ;AAC5C;AAQO,SAAS,iBAAiB,IAAA,EAAsB;IACrD,IAAI,OAAO,eAAe,eAAe,OAAO,WAAW,IAAA,KAAS,YAAY;QAC9E,OAAO,WAAW,IAAA,CAAK,IAAI;IAC7B;IACA,OAAO,OAAO,IAAA,CAAK,MAAM,QAAQ,EAAE,QAAA,CAAS,OAAO;AACrD;AAUO,SAAS,UAAU,IAAA,EAAe,IAAA,EAAwB;IAG/D,MAAM,YAAY,CAAC,QAAyB;QAE1C,IAAI,QAAQ,QAAQ,QAAQ,KAAA,EAAW,CAAA,OAAO,KAAK,SAAA,CAAU,GAAG;QAChE,IAAI,OAAO,QAAQ,SAAU,CAAA,OAAO,KAAK,SAAA,CAAU,GAAG;QAGtD,IAAI,MAAM,OAAA,CAAQ,GAAG,GAAG;YACtB,OAAO,KAAK,SAAA,CACV,IAAI,GAAA,CAAI,CAAA,OACN,OAAO,SAAS,YAAY,SAAS,OAAO,KAAK,KAAA,CAAM,UAAU,IAAI,CAAC,IAAI;QAGhF;QAGA,MAAM,SAAkC,CAAC;QACzC,OAAO,IAAA,CAAK,GAA8B,EACvC,IAAA,CAAK,EACL,OAAA,CAAQ,CAAA,QAAO;YACd,MAAM,QAAS,GAAA,CAAgC,GAAG,CAAA;YAClD,MAAA,CAAO,GAAG,CAAA,GACR,OAAO,UAAU,YAAY,UAAU,OAAO,KAAK,KAAA,CAAM,UAAU,KAAK,CAAC,IAAI;QACjF,CAAC;QACH,OAAO,KAAK,SAAA,CAAU,MAAM;IAC9B;IAEA,IAAI;QACF,OAAO,UAAU,IAAI,MAAM,UAAU,IAAI;IAC3C,EAAA,OAAQ;QAEN,OAAO,KAAK,SAAA,CAAU,IAAI,MAAM,KAAK,SAAA,CAAU,IAAI;IACrD;AACF"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/http/x402HTTPResourceServer.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/http/httpFacilitatorClient.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/http/x402HTTPClient.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/http/index.ts"],"sourcesContent":["import { x402ResourceServer } from \"../server\";\nimport {\n  decodePaymentSignatureHeader,\n  encodePaymentRequiredHeader,\n  encodePaymentResponseHeader,\n} from \".\";\nimport {\n  PaymentPayload,\n  PaymentRequired,\n  SettleResponse,\n  Price,\n  Network,\n  PaymentRequirements,\n} from \"../types\";\nimport { x402Version } from \"..\";\n\n/**\n * Framework-agnostic HTTP adapter interface\n * Implementations provide framework-specific HTTP operations\n */\nexport interface HTTPAdapter {\n  getHeader(name: string): string | undefined;\n  getMethod(): string;\n  getPath(): string;\n  getUrl(): string;\n  getAcceptHeader(): string;\n  getUserAgent(): string;\n\n  /**\n   * Get query parameters from the request URL\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams?(): Record<string, string | string[]>;\n\n  /**\n   * Get a specific query parameter by name\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam?(name: string): string | string[] | undefined;\n\n  /**\n   * Get the parsed request body\n   * Framework adapters should parse JSON/form data appropriately\n   *\n   * @returns The parsed request body\n   */\n  getBody?(): unknown;\n}\n\n/**\n * Paywall configuration for HTML responses\n */\nexport interface PaywallConfig {\n  appName?: string;\n  appLogo?: string;\n  sessionTokenEndpoint?: string;\n  currentUrl?: string;\n  testnet?: boolean;\n}\n\n/**\n * Paywall provider interface for generating HTML\n */\nexport interface PaywallProvider {\n  generateHtml(paymentRequired: PaymentRequired, config?: PaywallConfig): string;\n}\n\n/**\n * Dynamic payTo function that receives HTTP request context\n */\nexport type DynamicPayTo = (context: HTTPRequestContext) => string | Promise<string>;\n\n/**\n * Dynamic price function that receives HTTP request context\n */\nexport type DynamicPrice = (context: HTTPRequestContext) => Price | Promise<Price>;\n\n/**\n * Result of the unpaid response callback containing content type and body.\n */\nexport interface UnpaidResponseResult {\n  /**\n   * The content type for the response (e.g., 'application/json', 'text/plain').\n   */\n  contentType: string;\n\n  /**\n   * The response body to include in the 402 response.\n   */\n  body: unknown;\n}\n\n/**\n * Dynamic function to generate a custom response for unpaid requests.\n * Receives the HTTP request context and returns the content type and body to include in the 402 response.\n */\nexport type UnpaidResponseBody = (\n  context: HTTPRequestContext,\n) => UnpaidResponseResult | Promise<UnpaidResponseResult>;\n\n/**\n * A single payment option for a route\n * Represents one way a client can pay for access to the resource\n */\nexport interface PaymentOption {\n  scheme: string;\n  payTo: string | DynamicPayTo;\n  price: Price | DynamicPrice;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>;\n}\n\n/**\n * Route configuration for HTTP endpoints\n *\n * The 'accepts' field defines payment options for the route.\n * Can be a single PaymentOption or an array of PaymentOptions for multiple payment methods.\n */\nexport interface RouteConfig {\n  // Payment option(s): single or array\n  accepts: PaymentOption | PaymentOption[];\n\n  // HTTP-specific metadata\n  resource?: string;\n  description?: string;\n  mimeType?: string;\n  customPaywallHtml?: string;\n\n  /**\n   * Optional callback to generate a custom response for unpaid API requests.\n   * This allows servers to return preview data, error messages, or other content\n   * when a request lacks payment.\n   *\n   * For browser requests (Accept: text/html), the paywall HTML takes precedence.\n   * This callback is only used for API clients.\n   *\n   * If not provided, defaults to { contentType: 'application/json', body: {} }.\n   *\n   * @param context - The HTTP request context\n   * @returns An object containing both contentType and body for the 402 response\n   */\n  unpaidResponseBody?: UnpaidResponseBody;\n\n  // Extensions\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Routes configuration - maps path patterns to route configs\n */\nexport type RoutesConfig = Record<string, RouteConfig> | RouteConfig;\n\n/**\n * Compiled route for efficient matching\n */\nexport interface CompiledRoute {\n  verb: string;\n  regex: RegExp;\n  config: RouteConfig;\n}\n\n/**\n * HTTP request context that encapsulates all request data\n */\nexport interface HTTPRequestContext {\n  adapter: HTTPAdapter;\n  path: string;\n  method: string;\n  paymentHeader?: string;\n}\n\n/**\n * HTTP response instructions for the framework middleware\n */\nexport interface HTTPResponseInstructions {\n  status: number;\n  headers: Record<string, string>;\n  body?: unknown; // e.g. Paywall for web browser requests, but could be any other type\n  isHtml?: boolean; // e.g. if body is a paywall, then isHtml is true\n}\n\n/**\n * Result of processing an HTTP request for payment\n */\nexport type HTTPProcessResult =\n  | { type: \"no-payment-required\" }\n  | {\n      type: \"payment-verified\";\n      paymentPayload: PaymentPayload;\n      paymentRequirements: PaymentRequirements;\n    }\n  | { type: \"payment-error\"; response: HTTPResponseInstructions };\n\n/**\n * Result of processSettlement\n */\nexport type ProcessSettleSuccessResponse = SettleResponse & {\n  success: true;\n  headers: Record<string, string>;\n  requirements: PaymentRequirements;\n};\n\nexport type ProcessSettleFailureResponse = SettleResponse & {\n  success: false;\n  errorReason: string;\n};\n\nexport type ProcessSettleResultResponse =\n  | ProcessSettleSuccessResponse\n  | ProcessSettleFailureResponse;\n\n/**\n * Represents a validation error for a specific route's payment configuration.\n */\nexport interface RouteValidationError {\n  /** The route pattern (e.g., \"GET /api/weather\") */\n  routePattern: string;\n  /** The payment scheme that failed validation */\n  scheme: string;\n  /** The network that failed validation */\n  network: Network;\n  /** The type of validation failure */\n  reason: \"missing_scheme\" | \"missing_facilitator\";\n  /** Human-readable error message */\n  message: string;\n}\n\n/**\n * Error thrown when route configuration validation fails.\n */\nexport class RouteConfigurationError extends Error {\n  /** The validation errors that caused this exception */\n  public readonly errors: RouteValidationError[];\n\n  /**\n   * Creates a new RouteConfigurationError with the given validation errors.\n   *\n   * @param errors - The validation errors that caused this exception.\n   */\n  constructor(errors: RouteValidationError[]) {\n    const message = `x402 Route Configuration Errors:\\n${errors.map(e => `  - ${e.message}`).join(\"\\n\")}`;\n    super(message);\n    this.name = \"RouteConfigurationError\";\n    this.errors = errors;\n  }\n}\n\n/**\n * HTTP-enhanced x402 resource server\n * Provides framework-agnostic HTTP protocol handling\n */\nexport class x402HTTPResourceServer {\n  private ResourceServer: x402ResourceServer;\n  private compiledRoutes: CompiledRoute[] = [];\n  private routesConfig: RoutesConfig;\n  private paywallProvider?: PaywallProvider;\n\n  /**\n   * Creates a new x402HTTPResourceServer instance.\n   *\n   * @param ResourceServer - The core x402ResourceServer instance to use\n   * @param routes - Route configuration for payment-protected endpoints\n   */\n  constructor(ResourceServer: x402ResourceServer, routes: RoutesConfig) {\n    this.ResourceServer = ResourceServer;\n    this.routesConfig = routes;\n\n    // Handle both single route and multiple routes\n    const normalizedRoutes =\n      typeof routes === \"object\" && !(\"accepts\" in routes)\n        ? (routes as Record<string, RouteConfig>)\n        : { \"*\": routes as RouteConfig };\n\n    for (const [pattern, config] of Object.entries(normalizedRoutes)) {\n      const parsed = this.parseRoutePattern(pattern);\n      this.compiledRoutes.push({\n        verb: parsed.verb,\n        regex: parsed.regex,\n        config,\n      });\n    }\n  }\n\n  /**\n   * Initialize the HTTP resource server.\n   *\n   * This method initializes the underlying resource server (fetching facilitator support)\n   * and then validates that all route payment configurations have corresponding\n   * registered schemes and facilitator support.\n   *\n   * @throws RouteConfigurationError if any route's payment options don't have\n   *         corresponding registered schemes or facilitator support\n   *\n   * @example\n   * ```typescript\n   * const httpServer = new x402HTTPResourceServer(server, routes);\n   * await httpServer.initialize();\n   * ```\n   */\n  async initialize(): Promise<void> {\n    // First, initialize the underlying resource server (fetches facilitator support)\n    await this.ResourceServer.initialize();\n\n    // Then validate route configuration\n    const errors = this.validateRouteConfiguration();\n    if (errors.length > 0) {\n      throw new RouteConfigurationError(errors);\n    }\n  }\n\n  /**\n   * Register a custom paywall provider for generating HTML\n   *\n   * @param provider - PaywallProvider instance\n   * @returns This service instance for chaining\n   */\n  registerPaywallProvider(provider: PaywallProvider): this {\n    this.paywallProvider = provider;\n    return this;\n  }\n\n  /**\n   * Process HTTP request and return response instructions\n   * This is the main entry point for framework middleware\n   *\n   * @param context - HTTP request context\n   * @param paywallConfig - Optional paywall configuration\n   * @returns Process result indicating next action for middleware\n   */\n  async processHTTPRequest(\n    context: HTTPRequestContext,\n    paywallConfig?: PaywallConfig,\n  ): Promise<HTTPProcessResult> {\n    const { adapter, path, method } = context;\n\n    // Find matching route\n    const routeConfig = this.getRouteConfig(path, method);\n    if (!routeConfig) {\n      return { type: \"no-payment-required\" }; // No payment required for this route\n    }\n\n    // Normalize accepts field to array of payment options\n    const paymentOptions = this.normalizePaymentOptions(routeConfig);\n\n    // Check for payment header (v1 or v2)\n    const paymentPayload = this.extractPayment(adapter);\n\n    // Create resource info, using config override if provided\n    const resourceInfo = {\n      url: routeConfig.resource || context.adapter.getUrl(),\n      description: routeConfig.description || \"\",\n      mimeType: routeConfig.mimeType || \"\",\n    };\n\n    // Build requirements from all payment options\n    // (this method handles resolving dynamic functions internally)\n    const requirements = await this.ResourceServer.buildPaymentRequirementsFromOptions(\n      paymentOptions,\n      context,\n    );\n\n    let extensions = routeConfig.extensions;\n    if (extensions) {\n      extensions = this.ResourceServer.enrichExtensions(extensions, context);\n    }\n\n    const paymentRequired = this.ResourceServer.createPaymentRequiredResponse(\n      requirements,\n      resourceInfo,\n      !paymentPayload ? \"Payment required\" : undefined,\n      extensions,\n    );\n\n    // If no payment provided\n    if (!paymentPayload) {\n      // Resolve custom unpaid response body if provided\n      const unpaidBody = routeConfig.unpaidResponseBody\n        ? await routeConfig.unpaidResponseBody(context)\n        : undefined;\n\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(\n          paymentRequired,\n          this.isWebBrowser(adapter),\n          paywallConfig,\n          routeConfig.customPaywallHtml,\n          unpaidBody,\n        ),\n      };\n    }\n\n    // Verify payment\n    try {\n      const matchingRequirements = this.ResourceServer.findMatchingRequirements(\n        paymentRequired.accepts,\n        paymentPayload,\n      );\n\n      if (!matchingRequirements) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements\",\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      const verifyResult = await this.ResourceServer.verifyPayment(\n        paymentPayload,\n        matchingRequirements,\n      );\n\n      if (!verifyResult.isValid) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          verifyResult.invalidReason,\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      // Payment is valid, return data needed for settlement\n      return {\n        type: \"payment-verified\",\n        paymentPayload,\n        paymentRequirements: matchingRequirements,\n      };\n    } catch (error) {\n      const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n        requirements,\n        resourceInfo,\n        error instanceof Error ? error.message : \"Payment verification failed\",\n        routeConfig.extensions,\n      );\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n      };\n    }\n  }\n\n  /**\n   * Process settlement after successful response\n   *\n   * @param paymentPayload - The verified payment payload\n   * @param requirements - The matching payment requirements\n   * @returns ProcessSettleResultResponse - SettleResponse with headers if success or errorReason if failure\n   */\n  async processSettlement(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<ProcessSettleResultResponse> {\n    try {\n      const settleResponse = await this.ResourceServer.settlePayment(paymentPayload, requirements);\n\n      if (!settleResponse.success) {\n        return {\n          ...settleResponse,\n          success: false,\n          errorReason: settleResponse.errorReason || \"Settlement failed\",\n        };\n      }\n\n      return {\n        ...settleResponse,\n        success: true,\n        headers: this.createSettlementHeaders(settleResponse, requirements),\n        requirements,\n      };\n    } catch (error) {\n      throw new Error(error instanceof Error ? error.message : \"Settlement failed\");\n    }\n  }\n\n  /**\n   * Check if a request requires payment based on route configuration\n   *\n   * @param context - HTTP request context\n   * @returns True if the route requires payment, false otherwise\n   */\n  requiresPayment(context: HTTPRequestContext): boolean {\n    const routeConfig = this.getRouteConfig(context.path, context.method);\n    return routeConfig !== undefined;\n  }\n\n  /**\n   * Normalizes a RouteConfig's accepts field into an array of PaymentOptions\n   * Handles both single PaymentOption and array formats\n   *\n   * @param routeConfig - Route configuration\n   * @returns Array of payment options\n   */\n  private normalizePaymentOptions(routeConfig: RouteConfig): PaymentOption[] {\n    return Array.isArray(routeConfig.accepts) ? routeConfig.accepts : [routeConfig.accepts];\n  }\n\n  /**\n   * Validates that all payment options in routes have corresponding registered schemes\n   * and facilitator support.\n   *\n   * @returns Array of validation errors (empty if all routes are valid)\n   */\n  private validateRouteConfiguration(): RouteValidationError[] {\n    const errors: RouteValidationError[] = [];\n\n    // Normalize routes to array of [pattern, config] pairs\n    const normalizedRoutes =\n      typeof this.routesConfig === \"object\" && !(\"accepts\" in this.routesConfig)\n        ? Object.entries(this.routesConfig as Record<string, RouteConfig>)\n        : [[\"*\", this.routesConfig as RouteConfig] as [string, RouteConfig]];\n\n    for (const [pattern, config] of normalizedRoutes) {\n      const paymentOptions = this.normalizePaymentOptions(config);\n\n      for (const option of paymentOptions) {\n        // Check 1: Is scheme registered?\n        if (!this.ResourceServer.hasRegisteredScheme(option.network, option.scheme)) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_scheme\",\n            message: `Route \"${pattern}\": No scheme implementation registered for \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n          // Skip facilitator check if scheme isn't registered\n          continue;\n        }\n\n        // Check 2: Does facilitator support this scheme/network combination?\n        const supportedKind = this.ResourceServer.getSupportedKind(\n          x402Version,\n          option.network,\n          option.scheme,\n        );\n\n        if (!supportedKind) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_facilitator\",\n            message: `Route \"${pattern}\": Facilitator does not support scheme \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Get route configuration for a request\n   *\n   * @param path - Request path\n   * @param method - HTTP method\n   * @returns Route configuration or undefined if no match\n   */\n  private getRouteConfig(path: string, method: string): RouteConfig | undefined {\n    const normalizedPath = this.normalizePath(path);\n    const upperMethod = method.toUpperCase();\n\n    const matchingRoute = this.compiledRoutes.find(\n      route =>\n        route.regex.test(normalizedPath) && (route.verb === \"*\" || route.verb === upperMethod),\n    );\n\n    return matchingRoute?.config;\n  }\n\n  /**\n   * Extract payment from HTTP headers (handles v1 and v2)\n   *\n   * @param adapter - HTTP adapter\n   * @returns Decoded payment payload or null\n   */\n  private extractPayment(adapter: HTTPAdapter): PaymentPayload | null {\n    // Check v2 header first (PAYMENT-SIGNATURE)\n    const header = adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"PAYMENT-SIGNATURE\");\n\n    if (header) {\n      try {\n        return decodePaymentSignatureHeader(header);\n      } catch (error) {\n        console.warn(\"Failed to decode PAYMENT-SIGNATURE header:\", error);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if request is from a web browser\n   *\n   * @param adapter - HTTP adapter\n   * @returns True if request appears to be from a browser\n   */\n  private isWebBrowser(adapter: HTTPAdapter): boolean {\n    const accept = adapter.getAcceptHeader();\n    const userAgent = adapter.getUserAgent();\n    return accept.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n  }\n\n  /**\n   * Create HTTP response instructions from payment required\n   *\n   * @param paymentRequired - Payment requirements\n   * @param isWebBrowser - Whether request is from browser\n   * @param paywallConfig - Paywall configuration\n   * @param customHtml - Custom HTML template\n   * @param unpaidResponse - Optional custom response (content type and body) for unpaid API requests\n   * @returns Response instructions\n   */\n  private createHTTPResponse(\n    paymentRequired: PaymentRequired,\n    isWebBrowser: boolean,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n    unpaidResponse?: UnpaidResponseResult,\n  ): HTTPResponseInstructions {\n    if (isWebBrowser) {\n      const html = this.generatePaywallHTML(paymentRequired, paywallConfig, customHtml);\n      return {\n        status: 402,\n        headers: { \"Content-Type\": \"text/html\" },\n        body: html,\n        isHtml: true,\n      };\n    }\n\n    const response = this.createHTTPPaymentRequiredResponse(paymentRequired);\n\n    // Use callback result if provided, otherwise default to JSON with empty object\n    const contentType = unpaidResponse ? unpaidResponse.contentType : \"application/json\";\n    const body = unpaidResponse ? unpaidResponse.body : {};\n\n    return {\n      status: 402,\n      headers: {\n        \"Content-Type\": contentType,\n        ...response.headers,\n      },\n      body,\n    };\n  }\n\n  /**\n   * Create HTTP payment required response (v1 puts in body, v2 puts in header)\n   *\n   * @param paymentRequired - Payment required object\n   * @returns Headers and body for the HTTP response\n   */\n  private createHTTPPaymentRequiredResponse(paymentRequired: PaymentRequired): {\n    headers: Record<string, string>;\n  } {\n    return {\n      headers: {\n        \"PAYMENT-REQUIRED\": encodePaymentRequiredHeader(paymentRequired),\n      },\n    };\n  }\n\n  /**\n   * Create settlement response headers\n   *\n   * @param settleResponse - Settlement response\n   * @param requirements - Payment requirements that were settled\n   * @returns Headers to add to response\n   */\n  private createSettlementHeaders(\n    settleResponse: SettleResponse,\n    requirements: PaymentRequirements,\n  ): Record<string, string> {\n    const encoded = encodePaymentResponseHeader({\n      ...settleResponse,\n      requirements,\n    });\n    return { \"PAYMENT-RESPONSE\": encoded };\n  }\n\n  /**\n   * Parse route pattern into verb and regex\n   *\n   * @param pattern - Route pattern like \"GET /api/*\" or \"/api/[id]\"\n   * @returns Parsed pattern with verb and regex\n   */\n  private parseRoutePattern(pattern: string): { verb: string; regex: RegExp } {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n\n    const regex = new RegExp(\n      `^${\n        path\n          .replace(/[$()+.?^{|}]/g, \"\\\\$&\") // Escape regex special chars\n          .replace(/\\*/g, \".*?\") // Wildcards\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Parameters\n          .replace(/\\//g, \"\\\\/\") // Escape slashes\n      }$`,\n      \"i\",\n    );\n\n    return { verb: verb.toUpperCase(), regex };\n  }\n\n  /**\n   * Normalize path for matching\n   *\n   * @param path - Raw path from request\n   * @returns Normalized path\n   */\n  private normalizePath(path: string): string {\n    try {\n      const pathWithoutQuery = path.split(/[?#]/)[0];\n      const decodedPath = decodeURIComponent(pathWithoutQuery);\n      return decodedPath\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\/+/g, \"/\")\n        .replace(/(.+?)\\/+$/, \"$1\");\n    } catch {\n      return path;\n    }\n  }\n\n  /**\n   * Generate paywall HTML for browser requests\n   *\n   * @param paymentRequired - Payment required response\n   * @param paywallConfig - Optional paywall configuration\n   * @param customHtml - Optional custom HTML template\n   * @returns HTML string\n   */\n  private generatePaywallHTML(\n    paymentRequired: PaymentRequired,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n  ): string {\n    if (customHtml) {\n      return customHtml;\n    }\n\n    // Use custom paywall provider if set\n    if (this.paywallProvider) {\n      return this.paywallProvider.generateHtml(paymentRequired, paywallConfig);\n    }\n\n    // Try to use @x402/paywall if available (optional dependency)\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const paywall = require(\"@x402/paywall\");\n      const displayAmount = this.getDisplayAmount(paymentRequired);\n      const resource = paymentRequired.resource;\n\n      return paywall.getPaywallHtml({\n        amount: displayAmount,\n        paymentRequired,\n        currentUrl: resource?.url || paywallConfig?.currentUrl || \"\",\n        testnet: paywallConfig?.testnet ?? true,\n        appName: paywallConfig?.appName,\n        appLogo: paywallConfig?.appLogo,\n        sessionTokenEndpoint: paywallConfig?.sessionTokenEndpoint,\n      });\n    } catch {\n      // @x402/paywall not installed, fall back to basic HTML\n    }\n\n    // Fallback: Basic HTML paywall\n    const resource = paymentRequired.resource;\n    const displayAmount = this.getDisplayAmount(paymentRequired);\n\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Payment Required</title>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        </head>\n        <body>\n          <div style=\"max-width: 600px; margin: 50px auto; padding: 20px; font-family: system-ui, -apple-system, sans-serif;\">\n            ${paywallConfig?.appLogo ? `<img src=\"${paywallConfig.appLogo}\" alt=\"${paywallConfig.appName || \"App\"}\" style=\"max-width: 200px; margin-bottom: 20px;\">` : \"\"}\n            <h1>Payment Required</h1>\n            ${resource ? `<p><strong>Resource:</strong> ${resource.description || resource.url}</p>` : \"\"}\n            <p><strong>Amount:</strong> $${displayAmount.toFixed(2)} USDC</p>\n            <div id=\"payment-widget\" \n                 data-requirements='${JSON.stringify(paymentRequired)}'\n                 data-app-name=\"${paywallConfig?.appName || \"\"}\"\n                 data-testnet=\"${paywallConfig?.testnet || false}\">\n              <!-- Install @x402/paywall for full wallet integration -->\n              <p style=\"margin-top: 2rem; padding: 1rem; background: #fef3c7; border-radius: 0.5rem;\">\n                <strong>Note:</strong> Install <code>@x402/paywall</code> for full wallet connection and payment UI.\n              </p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Extract display amount from payment requirements.\n   *\n   * @param paymentRequired - The payment required object\n   * @returns The display amount in decimal format\n   */\n  private getDisplayAmount(paymentRequired: PaymentRequired): number {\n    const accepts = paymentRequired.accepts;\n    if (accepts && accepts.length > 0) {\n      const firstReq = accepts[0];\n      if (\"amount\" in firstReq) {\n        // V2 format\n        return parseFloat(firstReq.amount) / 1000000; // Assuming USDC with 6 decimals\n      }\n    }\n    return 0;\n  }\n}\n","import { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport { VerifyResponse, SettleResponse, SupportedResponse } from \"../types/facilitator\";\n\nconst DEFAULT_FACILITATOR_URL = \"https://x402.org/facilitator\";\n\nexport interface FacilitatorConfig {\n  url?: string;\n  createAuthHeaders?: () => Promise<{\n    verify: Record<string, string>;\n    settle: Record<string, string>;\n    supported: Record<string, string>;\n  }>;\n}\n\n/**\n * Interface for facilitator clients\n * Can be implemented for HTTP-based or local facilitators\n */\nexport interface FacilitatorClient {\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse>;\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse>;\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  getSupported(): Promise<SupportedResponse>;\n}\n\n/**\n * HTTP-based client for interacting with x402 facilitator services\n * Handles HTTP communication with facilitator endpoints\n */\nexport class HTTPFacilitatorClient implements FacilitatorClient {\n  readonly url: string;\n  private readonly _createAuthHeaders?: FacilitatorConfig[\"createAuthHeaders\"];\n\n  /**\n   * Creates a new HTTPFacilitatorClient instance.\n   *\n   * @param config - Configuration options for the facilitator client\n   */\n  constructor(config?: FacilitatorConfig) {\n    this.url = config?.url || DEFAULT_FACILITATOR_URL;\n    this._createAuthHeaders = config?.createAuthHeaders;\n  }\n\n  /**\n   * Verify a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to verify\n   * @param paymentRequirements - The requirements to verify against\n   * @returns Verification response\n   */\n  async verify(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"verify\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/verify`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator verify failed (${response.status}): ${errorText}`);\n    }\n\n    return (await response.json()) as VerifyResponse;\n  }\n\n  /**\n   * Settle a payment with the facilitator\n   *\n   * @param paymentPayload - The payment to settle\n   * @param paymentRequirements - The requirements for settlement\n   * @returns Settlement response\n   */\n  async settle(\n    paymentPayload: PaymentPayload,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"settle\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/settle`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        x402Version: paymentPayload.x402Version,\n        paymentPayload: this.toJsonSafe(paymentPayload),\n        paymentRequirements: this.toJsonSafe(paymentRequirements),\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator settle failed (${response.status}): ${errorText}`);\n    }\n\n    return (await response.json()) as SettleResponse;\n  }\n\n  /**\n   * Get supported payment kinds and extensions from the facilitator\n   *\n   * @returns Supported payment kinds and extensions\n   */\n  async getSupported(): Promise<SupportedResponse> {\n    let headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n\n    if (this._createAuthHeaders) {\n      const authHeaders = await this.createAuthHeaders(\"supported\");\n      headers = { ...headers, ...authHeaders.headers };\n    }\n\n    const response = await fetch(`${this.url}/supported`, {\n      method: \"GET\",\n      headers,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => response.statusText);\n      throw new Error(`Facilitator getSupported failed (${response.status}): ${errorText}`);\n    }\n\n    return (await response.json()) as SupportedResponse;\n  }\n\n  /**\n   * Creates authentication headers for a specific path.\n   *\n   * @param path - The path to create authentication headers for (e.g., \"verify\", \"settle\", \"supported\")\n   * @returns An object containing the authentication headers for the specified path\n   */\n  async createAuthHeaders(path: string): Promise<{\n    headers: Record<string, string>;\n  }> {\n    if (this._createAuthHeaders) {\n      const authHeaders = (await this._createAuthHeaders()) as Record<\n        string,\n        Record<string, string>\n      >;\n      return {\n        headers: authHeaders[path] ?? {},\n      };\n    }\n    return {\n      headers: {},\n    };\n  }\n\n  /**\n   * Helper to convert objects to JSON-safe format.\n   * Handles BigInt and other non-JSON types.\n   *\n   * @param obj - The object to convert\n   * @returns The JSON-safe representation of the object\n   */\n  private toJsonSafe(obj: unknown): unknown {\n    return JSON.parse(\n      JSON.stringify(obj, (_, value) => (typeof value === \"bigint\" ? value.toString() : value)),\n    );\n  }\n}\n","import {\n  decodePaymentRequiredHeader,\n  decodePaymentResponseHeader,\n  encodePaymentSignatureHeader,\n} from \".\";\nimport { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { x402Client } from \"../client/x402Client\";\n\n/**\n * HTTP-specific client for handling x402 payment protocol over HTTP.\n *\n * Wraps a x402Client to provide HTTP-specific encoding/decoding functionality\n * for payment headers and responses while maintaining the builder pattern.\n */\nexport class x402HTTPClient {\n  /**\n   * Creates a new x402HTTPClient instance.\n   *\n   * @param client - The underlying x402Client for payment logic\n   */\n  constructor(private readonly client: x402Client) {}\n\n  /**\n   * Encodes a payment payload into appropriate HTTP headers based on version.\n   *\n   * @param paymentPayload - The payment payload to encode\n   * @returns HTTP headers containing the encoded payment signature\n   */\n  encodePaymentSignatureHeader(paymentPayload: PaymentPayload): Record<string, string> {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return {\n          \"PAYMENT-SIGNATURE\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      case 1:\n        return {\n          \"X-PAYMENT\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Extracts payment required information from HTTP response.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @param body - Optional response body for v1 compatibility\n   * @returns The payment required object\n   */\n  getPaymentRequiredResponse(\n    getHeader: (name: string) => string | null | undefined,\n    body?: unknown,\n  ): PaymentRequired {\n    // v2\n    const paymentRequired = getHeader(\"PAYMENT-REQUIRED\");\n    if (paymentRequired) {\n      return decodePaymentRequiredHeader(paymentRequired);\n    }\n\n    // v1\n    if (\n      body &&\n      body instanceof Object &&\n      \"x402Version\" in body &&\n      (body as PaymentRequired).x402Version === 1\n    ) {\n      return body as PaymentRequired;\n    }\n\n    throw new Error(\"Invalid payment required response\");\n  }\n\n  /**\n   * Extracts payment settlement response from HTTP headers.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @returns The settlement response object\n   */\n  getPaymentSettleResponse(getHeader: (name: string) => string | null | undefined): SettleResponse {\n    // v2\n    const paymentResponse = getHeader(\"PAYMENT-RESPONSE\");\n    if (paymentResponse) {\n      return decodePaymentResponseHeader(paymentResponse);\n    }\n\n    // v1\n    const xPaymentResponse = getHeader(\"X-PAYMENT-RESPONSE\");\n    if (xPaymentResponse) {\n      return decodePaymentResponseHeader(xPaymentResponse);\n    }\n\n    throw new Error(\"Payment response header not found\");\n  }\n\n  /**\n   * Creates a payment payload for the given payment requirements.\n   * Delegates to the underlying x402Client.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Promise resolving to the payment payload\n   */\n  async createPaymentPayload(paymentRequired: PaymentRequired): Promise<PaymentPayload> {\n    return this.client.createPaymentPayload(paymentRequired);\n  }\n}\n","import { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired, PaymentRequirements } from \"../types/payments\";\nimport { Base64EncodedRegex, safeBase64Decode, safeBase64Encode } from \"../utils\";\n\n// HTTP Methods that typically use query parameters\nexport type QueryParamMethods = \"GET\" | \"HEAD\" | \"DELETE\";\n\n// HTTP Methods that typically use request body\nexport type BodyMethods = \"POST\" | \"PUT\" | \"PATCH\";\n\n/**\n * Encodes a payment payload as a base64 header value.\n *\n * @param paymentPayload - The payment payload to encode\n * @returns Base64 encoded string representation of the payment payload\n */\nexport function encodePaymentSignatureHeader(paymentPayload: PaymentPayload): string {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\n\n/**\n * Decodes a base64 payment signature header into a payment payload.\n *\n * @param paymentSignatureHeader - The base64 encoded payment signature header\n * @returns The decoded payment payload\n */\nexport function decodePaymentSignatureHeader(paymentSignatureHeader: string): PaymentPayload {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader)) as PaymentPayload;\n}\n\n/**\n * Encodes a payment required object as a base64 header value.\n *\n * @param paymentRequired - The payment required object to encode\n * @returns Base64 encoded string representation of the payment required object\n */\nexport function encodePaymentRequiredHeader(paymentRequired: PaymentRequired): string {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\n\n/**\n * Decodes a base64 payment required header into a payment required object.\n *\n * @param paymentRequiredHeader - The base64 encoded payment required header\n * @returns The decoded payment required object\n */\nexport function decodePaymentRequiredHeader(paymentRequiredHeader: string): PaymentRequired {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader)) as PaymentRequired;\n}\n\n/**\n * Encodes a payment response as a base64 header value.\n *\n * @param paymentResponse - The payment response to encode\n * @returns Base64 encoded string representation of the payment response\n */\nexport function encodePaymentResponseHeader(\n  paymentResponse: SettleResponse & { requirements: PaymentRequirements },\n): string {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\n\n/**\n * Decodes a base64 payment response header into a settle response.\n *\n * @param paymentResponseHeader - The base64 encoded payment response header\n * @returns The decoded settle response\n */\nexport function decodePaymentResponseHeader(paymentResponseHeader: string): SettleResponse {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader)) as SettleResponse;\n}\n\n// Export HTTP service and types\nexport {\n  x402HTTPResourceServer,\n  HTTPAdapter,\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  PaymentOption,\n  RouteConfig,\n  RoutesConfig,\n  CompiledRoute,\n  DynamicPayTo,\n  DynamicPrice,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n  RouteConfigurationError,\n} from \"./x402HTTPResourceServer\";\nexport {\n  HTTPFacilitatorClient,\n  FacilitatorClient,\n  FacilitatorConfig,\n} from \"./httpFacilitatorClient\";\nexport { x402HTTPClient } from \"./x402HTTPClient\";\n"],"names":["displayAmount","resource"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0OO,IAAM,0BAAN,cAAsC,MAAM;IAAA;;;;GAAA,GASjD,YAAY,MAAA,CAAgC;QAC1C,MAAM,UAAU,CAAA;AAAA,EAAqC,OAAO,GAAA,CAAI,CAAA,IAAK,CAAA,IAAA,EAAO,EAAE,OAAO,EAAE,EAAE,IAAA,CAAK,IAAI,CAAC,EAAA;QACnG,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,GAAS;IAChB;AACF;AAMO,IAAM,yBAAN,MAA6B;IAAA;;;;;GAAA,GAYlC,YAAY,cAAA,EAAoC,MAAA,CAAsB;QAVtE,IAAA,CAAQ,cAAA,GAAkC,CAAC,CAAA;QAWzC,IAAA,CAAK,cAAA,GAAiB;QACtB,IAAA,CAAK,YAAA,GAAe;QAGpB,MAAM,mBACJ,OAAO,WAAW,YAAY,CAAA,CAAE,aAAa,MAAA,IACxC,SACD;YAAE,KAAK;QAAsB;QAEnC,KAAA,MAAW,CAAC,SAAS,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,gBAAgB,EAAG;YAChE,MAAM,SAAS,IAAA,CAAK,iBAAA,CAAkB,OAAO;YAC7C,IAAA,CAAK,cAAA,CAAe,IAAA,CAAK;gBACvB,MAAM,OAAO,IAAA;gBACb,OAAO,OAAO,KAAA;gBACd;YACF,CAAC;QACH;IACF;IAAA;;;;;;;;;;;;;;;GAAA,GAkBA,MAAM,aAA4B;QAEhC,MAAM,IAAA,CAAK,cAAA,CAAe,UAAA,CAAW;QAGrC,MAAM,SAAS,IAAA,CAAK,0BAAA,CAA2B;QAC/C,IAAI,OAAO,MAAA,GAAS,GAAG;YACrB,MAAM,IAAI,wBAAwB,MAAM;QAC1C;IACF;IAAA;;;;;GAAA,GAQA,wBAAwB,QAAA,EAAiC;QACvD,IAAA,CAAK,eAAA,GAAkB;QACvB,OAAO,IAAA;IACT;IAAA;;;;;;;GAAA,GAUA,MAAM,mBACJ,OAAA,EACA,aAAA,EAC4B;QAC5B,MAAM,EAAE,OAAA,EAAS,IAAA,EAAM,MAAA,CAAO,CAAA,GAAI;QAGlC,MAAM,cAAc,IAAA,CAAK,cAAA,CAAe,MAAM,MAAM;QACpD,IAAI,CAAC,aAAa;YAChB,OAAO;gBAAE,MAAM;YAAsB;QACvC;QAGA,MAAM,iBAAiB,IAAA,CAAK,uBAAA,CAAwB,WAAW;QAG/D,MAAM,iBAAiB,IAAA,CAAK,cAAA,CAAe,OAAO;QAGlD,MAAM,eAAe;YACnB,KAAK,YAAY,QAAA,IAAY,QAAQ,OAAA,CAAQ,MAAA,CAAO;YACpD,aAAa,YAAY,WAAA,IAAe;YACxC,UAAU,YAAY,QAAA,IAAY;QACpC;QAIA,MAAM,eAAe,MAAM,IAAA,CAAK,cAAA,CAAe,mCAAA,CAC7C,gBACA;QAGF,IAAI,aAAa,YAAY,UAAA;QAC7B,IAAI,YAAY;YACd,aAAa,IAAA,CAAK,cAAA,CAAe,gBAAA,CAAiB,YAAY,OAAO;QACvE;QAEA,MAAM,kBAAkB,IAAA,CAAK,cAAA,CAAe,6BAAA,CAC1C,cACA,cACA,CAAC,iBAAiB,qBAAqB,KAAA,GACvC;QAIF,IAAI,CAAC,gBAAgB;YAEnB,MAAM,aAAa,YAAY,kBAAA,GAC3B,MAAM,YAAY,kBAAA,CAAmB,OAAO,IAC5C,KAAA;YAEJ,OAAO;gBACL,MAAM;gBACN,UAAU,IAAA,CAAK,kBAAA,CACb,iBACA,IAAA,CAAK,YAAA,CAAa,OAAO,GACzB,eACA,YAAY,iBAAA,EACZ;YAEJ;QACF;QAGA,IAAI;YACF,MAAM,uBAAuB,IAAA,CAAK,cAAA,CAAe,wBAAA,CAC/C,gBAAgB,OAAA,EAChB;YAGF,IAAI,CAAC,sBAAsB;gBACzB,MAAM,gBAAgB,IAAA,CAAK,cAAA,CAAe,6BAAA,CACxC,cACA,cACA,oCACA,YAAY,UAAA;gBAEd,OAAO;oBACL,MAAM;oBACN,UAAU,IAAA,CAAK,kBAAA,CAAmB,eAAe,OAAO,aAAa;gBACvE;YACF;YAEA,MAAM,eAAe,MAAM,IAAA,CAAK,cAAA,CAAe,aAAA,CAC7C,gBACA;YAGF,IAAI,CAAC,aAAa,OAAA,EAAS;gBACzB,MAAM,gBAAgB,IAAA,CAAK,cAAA,CAAe,6BAAA,CACxC,cACA,cACA,aAAa,aAAA,EACb,YAAY,UAAA;gBAEd,OAAO;oBACL,MAAM;oBACN,UAAU,IAAA,CAAK,kBAAA,CAAmB,eAAe,OAAO,aAAa;gBACvE;YACF;YAGA,OAAO;gBACL,MAAM;gBACN;gBACA,qBAAqB;YACvB;QACF,EAAA,OAAS,OAAO;YACd,MAAM,gBAAgB,IAAA,CAAK,cAAA,CAAe,6BAAA,CACxC,cACA,cACA,iBAAiB,QAAQ,MAAM,OAAA,GAAU,+BACzC,YAAY,UAAA;YAEd,OAAO;gBACL,MAAM;gBACN,UAAU,IAAA,CAAK,kBAAA,CAAmB,eAAe,OAAO,aAAa;YACvE;QACF;IACF;IAAA;;;;;;GAAA,GASA,MAAM,kBACJ,cAAA,EACA,YAAA,EACsC;QACtC,IAAI;YACF,MAAM,iBAAiB,MAAM,IAAA,CAAK,cAAA,CAAe,aAAA,CAAc,gBAAgB,YAAY;YAE3F,IAAI,CAAC,eAAe,OAAA,EAAS;gBAC3B,OAAO;oBACL,GAAG,cAAA;oBACH,SAAS;oBACT,aAAa,eAAe,WAAA,IAAe;gBAC7C;YACF;YAEA,OAAO;gBACL,GAAG,cAAA;gBACH,SAAS;gBACT,SAAS,IAAA,CAAK,uBAAA,CAAwB,gBAAgB,YAAY;gBAClE;YACF;QACF,EAAA,OAAS,OAAO;YACd,MAAM,IAAI,MAAM,iBAAiB,QAAQ,MAAM,OAAA,GAAU,mBAAmB;QAC9E;IACF;IAAA;;;;;GAAA,GAQA,gBAAgB,OAAA,EAAsC;QACpD,MAAM,cAAc,IAAA,CAAK,cAAA,CAAe,QAAQ,IAAA,EAAM,QAAQ,MAAM;QACpE,OAAO,gBAAgB,KAAA;IACzB;IAAA;;;;;;GAAA,GASQ,wBAAwB,WAAA,EAA2C;QACzE,OAAO,MAAM,OAAA,CAAQ,YAAY,OAAO,IAAI,YAAY,OAAA,GAAU;YAAC,YAAY,OAAO;SAAA;IACxF;IAAA;;;;;GAAA,GAQQ,6BAAqD;QAC3D,MAAM,SAAiC,CAAC,CAAA;QAGxC,MAAM,mBACJ,OAAO,IAAA,CAAK,YAAA,KAAiB,YAAY,CAAA,CAAE,aAAa,IAAA,CAAK,YAAA,IACzD,OAAO,OAAA,CAAQ,IAAA,CAAK,YAA2C,IAC/D;YAAC;gBAAC;gBAAK,IAAA,CAAK,YAA2B;aAA0B;SAAA;QAEvE,KAAA,MAAW,CAAC,SAAS,MAAM,CAAA,IAAK,iBAAkB;YAChD,MAAM,iBAAiB,IAAA,CAAK,uBAAA,CAAwB,MAAM;YAE1D,KAAA,MAAW,UAAU,eAAgB;gBAEnC,IAAI,CAAC,IAAA,CAAK,cAAA,CAAe,mBAAA,CAAoB,OAAO,OAAA,EAAS,OAAO,MAAM,GAAG;oBAC3E,OAAO,IAAA,CAAK;wBACV,cAAc;wBACd,QAAQ,OAAO,MAAA;wBACf,SAAS,OAAO,OAAA;wBAChB,QAAQ;wBACR,SAAS,CAAA,OAAA,EAAU,OAAO,CAAA,4CAAA,EAA+C,OAAO,MAAM,CAAA,cAAA,EAAiB,OAAO,OAAO,CAAA,CAAA,CAAA;oBACvH,CAAC;oBAED;gBACF;gBAGA,MAAM,gBAAgB,IAAA,CAAK,cAAA,CAAe,gBAAA,CACxC,kLAAA,EACA,OAAO,OAAA,EACP,OAAO,MAAA;gBAGT,IAAI,CAAC,eAAe;oBAClB,OAAO,IAAA,CAAK;wBACV,cAAc;wBACd,QAAQ,OAAO,MAAA;wBACf,SAAS,OAAO,OAAA;wBAChB,QAAQ;wBACR,SAAS,CAAA,OAAA,EAAU,OAAO,CAAA,wCAAA,EAA2C,OAAO,MAAM,CAAA,cAAA,EAAiB,OAAO,OAAO,CAAA,CAAA,CAAA;oBACnH,CAAC;gBACH;YACF;QACF;QAEA,OAAO;IACT;IAAA;;;;;;GAAA,GASQ,eAAe,IAAA,EAAc,MAAA,EAAyC;QAC5E,MAAM,iBAAiB,IAAA,CAAK,aAAA,CAAc,IAAI;QAC9C,MAAM,cAAc,OAAO,WAAA,CAAY;QAEvC,MAAM,gBAAgB,IAAA,CAAK,cAAA,CAAe,IAAA,CACxC,CAAA,QACE,MAAM,KAAA,CAAM,IAAA,CAAK,cAAc,KAAA,CAAM,MAAM,IAAA,KAAS,OAAO,MAAM,IAAA,KAAS,WAAA;QAG9E,OAAO,eAAe;IACxB;IAAA;;;;;GAAA,GAQQ,eAAe,OAAA,EAA6C;QAElE,MAAM,SAAS,QAAQ,SAAA,CAAU,mBAAmB,KAAK,QAAQ,SAAA,CAAU,mBAAmB;QAE9F,IAAI,QAAQ;YACV,IAAI;gBACF,OAAO,6BAA6B,MAAM;YAC5C,EAAA,OAAS,OAAO;gBACd,QAAQ,IAAA,CAAK,8CAA8C,KAAK;YAClE;QACF;QAEA,OAAO;IACT;IAAA;;;;;GAAA,GAQQ,aAAa,OAAA,EAA+B;QAClD,MAAM,SAAS,QAAQ,eAAA,CAAgB;QACvC,MAAM,YAAY,QAAQ,YAAA,CAAa;QACvC,OAAO,OAAO,QAAA,CAAS,WAAW,KAAK,UAAU,QAAA,CAAS,SAAS;IACrE;IAAA;;;;;;;;;GAAA,GAYQ,mBACN,eAAA,EACA,YAAA,EACA,aAAA,EACA,UAAA,EACA,cAAA,EAC0B;QAC1B,IAAI,cAAc;YAChB,MAAM,OAAO,IAAA,CAAK,mBAAA,CAAoB,iBAAiB,eAAe,UAAU;YAChF,OAAO;gBACL,QAAQ;gBACR,SAAS;oBAAE,gBAAgB;gBAAY;gBACvC,MAAM;gBACN,QAAQ;YACV;QACF;QAEA,MAAM,WAAW,IAAA,CAAK,iCAAA,CAAkC,eAAe;QAGvE,MAAM,cAAc,iBAAiB,eAAe,WAAA,GAAc;QAClE,MAAM,OAAO,iBAAiB,eAAe,IAAA,GAAO,CAAC;QAErD,OAAO;YACL,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,GAAG,SAAS,OAAA;YACd;YACA;QACF;IACF;IAAA;;;;;GAAA,GAQQ,kCAAkC,eAAA,EAExC;QACA,OAAO;YACL,SAAS;gBACP,oBAAoB,4BAA4B,eAAe;YACjE;QACF;IACF;IAAA;;;;;;GAAA,GASQ,wBACN,cAAA,EACA,YAAA,EACwB;QACxB,MAAM,UAAU,4BAA4B;YAC1C,GAAG,cAAA;YACH;QACF,CAAC;QACD,OAAO;YAAE,oBAAoB;QAAQ;IACvC;IAAA;;;;;GAAA,GAQQ,kBAAkB,OAAA,EAAkD;QAC1E,MAAM,CAAC,MAAM,IAAI,CAAA,GAAI,QAAQ,QAAA,CAAS,GAAG,IAAI,QAAQ,KAAA,CAAM,KAAK,IAAI;YAAC;YAAK,OAAO;SAAA;QAEjF,MAAM,QAAQ,IAAI,OAChB,CAAA,CAAA,EACE,KACG,OAAA,CAAQ,iBAAiB,MAAM,EAC/B,OAAA,CAAQ,OAAO,KAAK,EACpB,OAAA,CAAQ,iBAAiB,OAAO,EAChC,OAAA,CAAQ,OAAO,KAAK,CACzB,CAAA,CAAA,CAAA,EACA;QAGF,OAAO;YAAE,MAAM,KAAK,WAAA,CAAY;YAAG;QAAM;IAC3C;IAAA;;;;;GAAA,GAQQ,cAAc,IAAA,EAAsB;QAC1C,IAAI;YACF,MAAM,mBAAmB,KAAK,KAAA,CAAM,MAAM,CAAA,CAAE,CAAC,CAAA;YAC7C,MAAM,cAAc,mBAAmB,gBAAgB;YACvD,OAAO,YACJ,OAAA,CAAQ,OAAO,GAAG,EAClB,OAAA,CAAQ,QAAQ,GAAG,EACnB,OAAA,CAAQ,aAAa,IAAI;QAC9B,EAAA,OAAQ;YACN,OAAO;QACT;IACF;IAAA;;;;;;;GAAA,GAUQ,oBACN,eAAA,EACA,aAAA,EACA,UAAA,EACQ;QACR,IAAI,YAAY;YACd,OAAO;QACT;QAGA,IAAI,IAAA,CAAK,eAAA,EAAiB;YACxB,OAAO,IAAA,CAAK,eAAA,CAAgB,YAAA,CAAa,iBAAiB,aAAa;QACzE;QAGA,IAAI;YAEF,MAAM,cAAU,gLAAA,EAAQ,eAAe;YACvC,MAAMA,iBAAgB,IAAA,CAAK,gBAAA,CAAiB,eAAe;YAC3D,MAAMC,YAAW,gBAAgB,QAAA;YAEjC,OAAO,QAAQ,cAAA,CAAe;gBAC5B,QAAQD;gBACR;gBACA,YAAYC,WAAU,OAAO,eAAe,cAAc;gBAC1D,SAAS,eAAe,WAAW;gBACnC,SAAS,eAAe;gBACxB,SAAS,eAAe;gBACxB,sBAAsB,eAAe;YACvC,CAAC;QACH,EAAA,OAAQ,CAER;QAGA,MAAM,WAAW,gBAAgB,QAAA;QACjC,MAAM,gBAAgB,IAAA,CAAK,gBAAA,CAAiB,eAAe;QAE3D,OAAO,CAAA;;;;;;;;;;YAAA,EAUG,eAAe,UAAU,CAAA,UAAA,EAAa,cAAc,OAAO,CAAA,OAAA,EAAU,cAAc,OAAA,IAAW,KAAK,CAAA,iDAAA,CAAA,GAAsD,EAAE,CAAA;;YAAA,EAE3J,WAAW,CAAA,8BAAA,EAAiC,SAAS,WAAA,IAAe,SAAS,GAAG,CAAA,IAAA,CAAA,GAAS,EAAE,CAAA;yCAAA,EAC9D,cAAc,OAAA,CAAQ,CAAC,CAAC,CAAA;;oCAAA,EAE7B,KAAK,SAAA,CAAU,eAAe,CAAC,CAAA;gCAAA,EACnC,eAAe,WAAW,EAAE,CAAA;+BAAA,EAC7B,eAAe,WAAW,KAAK,CAAA;;;;;;;;;IAAA,CAAA;IAU9D;IAAA;;;;;GAAA,GAQQ,iBAAiB,eAAA,EAA0C;QACjE,MAAM,UAAU,gBAAgB,OAAA;QAChC,IAAI,WAAW,QAAQ,MAAA,GAAS,GAAG;YACjC,MAAM,WAAW,OAAA,CAAQ,CAAC,CAAA;YAC1B,IAAI,YAAY,UAAU;gBAExB,OAAO,WAAW,SAAS,MAAM,IAAI;YACvC;QACF;QACA,OAAO;IACT;AACF;;ACvzBA,IAAM,0BAA0B;AAoDzB,IAAM,wBAAN,MAAyD;IAAA;;;;GAAA,GAS9D,YAAY,MAAA,CAA4B;QACtC,IAAA,CAAK,GAAA,GAAM,QAAQ,OAAO;QAC1B,IAAA,CAAK,kBAAA,GAAqB,QAAQ;IACpC;IAAA;;;;;;GAAA,GASA,MAAM,OACJ,cAAA,EACA,mBAAA,EACyB;QACzB,IAAI,UAAkC;YACpC,gBAAgB;QAClB;QAEA,IAAI,IAAA,CAAK,kBAAA,EAAoB;YAC3B,MAAM,cAAc,MAAM,IAAA,CAAK,iBAAA,CAAkB,QAAQ;YACzD,UAAU;gBAAE,GAAG,OAAA;gBAAS,GAAG,YAAY,OAAA;YAAQ;QACjD;QAEA,MAAM,WAAW,MAAM,MAAM,GAAG,IAAA,CAAK,GAAG,CAAA,OAAA,CAAA,EAAW;YACjD,QAAQ;YACR;YACA,MAAM,KAAK,SAAA,CAAU;gBACnB,aAAa,eAAe,WAAA;gBAC5B,gBAAgB,IAAA,CAAK,UAAA,CAAW,cAAc;gBAC9C,qBAAqB,IAAA,CAAK,UAAA,CAAW,mBAAmB;YAC1D,CAAC;QACH,CAAC;QAED,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,MAAM,YAAY,MAAM,SAAS,IAAA,CAAK,EAAE,KAAA,CAAM,IAAM,SAAS,UAAU;YACvE,MAAM,IAAI,MAAM,CAAA,2BAAA,EAA8B,SAAS,MAAM,CAAA,GAAA,EAAM,SAAS,EAAE;QAChF;QAEA,OAAQ,MAAM,SAAS,IAAA,CAAK;IAC9B;IAAA;;;;;;GAAA,GASA,MAAM,OACJ,cAAA,EACA,mBAAA,EACyB;QACzB,IAAI,UAAkC;YACpC,gBAAgB;QAClB;QAEA,IAAI,IAAA,CAAK,kBAAA,EAAoB;YAC3B,MAAM,cAAc,MAAM,IAAA,CAAK,iBAAA,CAAkB,QAAQ;YACzD,UAAU;gBAAE,GAAG,OAAA;gBAAS,GAAG,YAAY,OAAA;YAAQ;QACjD;QAEA,MAAM,WAAW,MAAM,MAAM,GAAG,IAAA,CAAK,GAAG,CAAA,OAAA,CAAA,EAAW;YACjD,QAAQ;YACR;YACA,MAAM,KAAK,SAAA,CAAU;gBACnB,aAAa,eAAe,WAAA;gBAC5B,gBAAgB,IAAA,CAAK,UAAA,CAAW,cAAc;gBAC9C,qBAAqB,IAAA,CAAK,UAAA,CAAW,mBAAmB;YAC1D,CAAC;QACH,CAAC;QAED,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,MAAM,YAAY,MAAM,SAAS,IAAA,CAAK,EAAE,KAAA,CAAM,IAAM,SAAS,UAAU;YACvE,MAAM,IAAI,MAAM,CAAA,2BAAA,EAA8B,SAAS,MAAM,CAAA,GAAA,EAAM,SAAS,EAAE;QAChF;QAEA,OAAQ,MAAM,SAAS,IAAA,CAAK;IAC9B;IAAA;;;;GAAA,GAOA,MAAM,eAA2C;QAC/C,IAAI,UAAkC;YACpC,gBAAgB;QAClB;QAEA,IAAI,IAAA,CAAK,kBAAA,EAAoB;YAC3B,MAAM,cAAc,MAAM,IAAA,CAAK,iBAAA,CAAkB,WAAW;YAC5D,UAAU;gBAAE,GAAG,OAAA;gBAAS,GAAG,YAAY,OAAA;YAAQ;QACjD;QAEA,MAAM,WAAW,MAAM,MAAM,GAAG,IAAA,CAAK,GAAG,CAAA,UAAA,CAAA,EAAc;YACpD,QAAQ;YACR;QACF,CAAC;QAED,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,MAAM,YAAY,MAAM,SAAS,IAAA,CAAK,EAAE,KAAA,CAAM,IAAM,SAAS,UAAU;YACvE,MAAM,IAAI,MAAM,CAAA,iCAAA,EAAoC,SAAS,MAAM,CAAA,GAAA,EAAM,SAAS,EAAE;QACtF;QAEA,OAAQ,MAAM,SAAS,IAAA,CAAK;IAC9B;IAAA;;;;;GAAA,GAQA,MAAM,kBAAkB,IAAA,EAErB;QACD,IAAI,IAAA,CAAK,kBAAA,EAAoB;YAC3B,MAAM,cAAe,MAAM,IAAA,CAAK,kBAAA,CAAmB;YAInD,OAAO;gBACL,SAAS,WAAA,CAAY,IAAI,CAAA,IAAK,CAAC;YACjC;QACF;QACA,OAAO;YACL,SAAS,CAAC;QACZ;IACF;IAAA;;;;;;GAAA,GASQ,WAAW,GAAA,EAAuB;QACxC,OAAO,KAAK,KAAA,CACV,KAAK,SAAA,CAAU,KAAK,CAAC,GAAG,QAAW,OAAO,UAAU,WAAW,MAAM,QAAA,CAAS,IAAI,KAAM;IAE5F;AACF;;ACjMO,IAAM,iBAAN,MAAqB;IAAA;;;;GAAA,GAM1B,YAA6B,MAAA,CAAoB;QAApB,IAAA,CAAA,MAAA,GAAA;IAAqB;IAAA;;;;;GAAA,GAQlD,6BAA6B,cAAA,EAAwD;QACnF,OAAQ,eAAe,WAAA,EAAa;YAClC,KAAK;gBACH,OAAO;oBACL,qBAAqB,6BAA6B,cAAc;gBAClE;YACF,KAAK;gBACH,OAAO;oBACL,aAAa,6BAA6B,cAAc;gBAC1D;YACF;gBACE,MAAM,IAAI,MACR,CAAA,0BAAA,EAA8B,eAAkC,WAAW,EAAA;QAEjF;IACF;IAAA;;;;;;GAAA,GASA,2BACE,SAAA,EACA,IAAA,EACiB;QAEjB,MAAM,kBAAkB,UAAU,kBAAkB;QACpD,IAAI,iBAAiB;YACnB,OAAO,4BAA4B,eAAe;QACpD;QAGA,IACE,QACA,gBAAgB,UAChB,iBAAiB,QAChB,KAAyB,WAAA,KAAgB,GAC1C;YACA,OAAO;QACT;QAEA,MAAM,IAAI,MAAM,mCAAmC;IACrD;IAAA;;;;;GAAA,GAQA,yBAAyB,SAAA,EAAwE;QAE/F,MAAM,kBAAkB,UAAU,kBAAkB;QACpD,IAAI,iBAAiB;YACnB,OAAO,4BAA4B,eAAe;QACpD;QAGA,MAAM,mBAAmB,UAAU,oBAAoB;QACvD,IAAI,kBAAkB;YACpB,OAAO,4BAA4B,gBAAgB;QACrD;QAEA,MAAM,IAAI,MAAM,mCAAmC;IACrD;IAAA;;;;;;GAAA,GASA,MAAM,qBAAqB,eAAA,EAA2D;QACpF,OAAO,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,eAAe;IACzD;AACF;;AC5FO,SAAS,6BAA6B,cAAA,EAAwC;IACnF,WAAO,uLAAA,EAAiB,KAAK,SAAA,CAAU,cAAc,CAAC;AACxD;AAQO,SAAS,6BAA6B,sBAAA,EAAgD;IAC3F,IAAI,CAAC,yLAAA,CAAmB,IAAA,CAAK,sBAAsB,GAAG;QACpD,MAAM,IAAI,MAAM,kCAAkC;IACpD;IACA,OAAO,KAAK,KAAA,KAAM,uLAAA,EAAiB,sBAAsB,CAAC;AAC5D;AAQO,SAAS,4BAA4B,eAAA,EAA0C;IACpF,WAAO,uLAAA,EAAiB,KAAK,SAAA,CAAU,eAAe,CAAC;AACzD;AAQO,SAAS,4BAA4B,qBAAA,EAAgD;IAC1F,IAAI,CAAC,yLAAA,CAAmB,IAAA,CAAK,qBAAqB,GAAG;QACnD,MAAM,IAAI,MAAM,iCAAiC;IACnD;IACA,OAAO,KAAK,KAAA,KAAM,uLAAA,EAAiB,qBAAqB,CAAC;AAC3D;AAQO,SAAS,4BACd,eAAA,EACQ;IACR,WAAO,uLAAA,EAAiB,KAAK,SAAA,CAAU,eAAe,CAAC;AACzD;AAQO,SAAS,4BAA4B,qBAAA,EAA+C;IACzF,IAAI,CAAC,yLAAA,CAAmB,IAAA,CAAK,qBAAqB,GAAG;QACnD,MAAM,IAAI,MAAM,iCAAiC;IACnD;IACA,OAAO,KAAK,KAAA,KAAM,uLAAA,EAAiB,qBAAqB,CAAC;AAC3D"}},
    {"offset": {"line": 794, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/core/src/server/x402ResourceServer.ts"],"sourcesContent":["import {\n  SettleResponse,\n  VerifyResponse,\n  SupportedResponse,\n  SupportedKind,\n} from \"../types/facilitator\";\nimport { PaymentPayload, PaymentRequirements, PaymentRequired } from \"../types/payments\";\nimport { SchemeNetworkServer } from \"../types/mechanisms\";\nimport { Price, Network, ResourceServerExtension } from \"../types\";\nimport { deepEqual, findByNetworkAndScheme } from \"../utils\";\nimport { FacilitatorClient, HTTPFacilitatorClient } from \"../http/httpFacilitatorClient\";\nimport { x402Version } from \"..\";\n\n/**\n * Configuration for a protected resource\n * Only contains payment-specific configuration, not resource metadata\n */\nexport interface ResourceConfig {\n  scheme: string;\n  payTo: string; // Payment recipient address\n  price: Price;\n  network: Network;\n  maxTimeoutSeconds?: number;\n}\n\n/**\n * Resource information for PaymentRequired response\n */\nexport interface ResourceInfo {\n  url: string;\n  description: string;\n  mimeType: string;\n}\n\n/**\n * Lifecycle Hook Context Interfaces\n */\n\nexport interface VerifyContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface VerifyResultContext extends VerifyContext {\n  result: VerifyResponse;\n}\n\nexport interface VerifyFailureContext extends VerifyContext {\n  error: Error;\n}\n\nexport interface SettleContext {\n  paymentPayload: PaymentPayload;\n  requirements: PaymentRequirements;\n}\n\nexport interface SettleResultContext extends SettleContext {\n  result: SettleResponse;\n}\n\nexport interface SettleFailureContext extends SettleContext {\n  error: Error;\n}\n\n/**\n * Lifecycle Hook Type Definitions\n */\n\nexport type BeforeVerifyHook = (\n  context: VerifyContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type AfterVerifyHook = (context: VerifyResultContext) => Promise<void>;\n\nexport type OnVerifyFailureHook = (\n  context: VerifyFailureContext,\n) => Promise<void | { recovered: true; result: VerifyResponse }>;\n\nexport type BeforeSettleHook = (\n  context: SettleContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type AfterSettleHook = (context: SettleResultContext) => Promise<void>;\n\nexport type OnSettleFailureHook = (\n  context: SettleFailureContext,\n) => Promise<void | { recovered: true; result: SettleResponse }>;\n\n/**\n * Core x402 protocol server for resource protection\n * Transport-agnostic implementation of the x402 payment protocol\n */\nexport class x402ResourceServer {\n  private facilitatorClients: FacilitatorClient[];\n  private registeredServerSchemes: Map<string, Map<string, SchemeNetworkServer>> = new Map();\n  private supportedResponsesMap: Map<number, Map<string, Map<string, SupportedResponse>>> =\n    new Map();\n  private facilitatorClientsMap: Map<number, Map<string, Map<string, FacilitatorClient>>> =\n    new Map();\n  private registeredExtensions: Map<string, ResourceServerExtension> = new Map();\n\n  private beforeVerifyHooks: BeforeVerifyHook[] = [];\n  private afterVerifyHooks: AfterVerifyHook[] = [];\n  private onVerifyFailureHooks: OnVerifyFailureHook[] = [];\n  private beforeSettleHooks: BeforeSettleHook[] = [];\n  private afterSettleHooks: AfterSettleHook[] = [];\n  private onSettleFailureHooks: OnSettleFailureHook[] = [];\n\n  /**\n   * Creates a new x402ResourceServer instance.\n   *\n   * @param facilitatorClients - Optional facilitator client(s) for payment processing\n   */\n  constructor(facilitatorClients?: FacilitatorClient | FacilitatorClient[]) {\n    // Normalize facilitator clients to array\n    if (!facilitatorClients) {\n      // No clients provided, create a default HTTP client\n      this.facilitatorClients = [new HTTPFacilitatorClient()];\n    } else if (Array.isArray(facilitatorClients)) {\n      // Array of clients provided\n      this.facilitatorClients =\n        facilitatorClients.length > 0 ? facilitatorClients : [new HTTPFacilitatorClient()];\n    } else {\n      // Single client provided\n      this.facilitatorClients = [facilitatorClients];\n    }\n  }\n\n  /**\n   * Register a scheme/network server implementation.\n   *\n   * @param network - The network identifier\n   * @param server - The scheme/network server implementation\n   * @returns The x402ResourceServer instance for chaining\n   */\n  register(network: Network, server: SchemeNetworkServer): x402ResourceServer {\n    if (!this.registeredServerSchemes.has(network)) {\n      this.registeredServerSchemes.set(network, new Map());\n    }\n\n    const serverByScheme = this.registeredServerSchemes.get(network)!;\n    if (!serverByScheme.has(server.scheme)) {\n      serverByScheme.set(server.scheme, server);\n    }\n\n    return this;\n  }\n\n  /**\n   * Check if a scheme is registered for a given network.\n   *\n   * @param network - The network identifier\n   * @param scheme - The payment scheme name\n   * @returns True if the scheme is registered for the network, false otherwise\n   */\n  hasRegisteredScheme(network: Network, scheme: string): boolean {\n    return !!findByNetworkAndScheme(this.registeredServerSchemes, scheme, network);\n  }\n\n  /**\n   * Registers a resource service extension that can enrich extension declarations.\n   *\n   * @param extension - The extension to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  registerExtension(extension: ResourceServerExtension): this {\n    this.registeredExtensions.set(extension.key, extension);\n    return this;\n  }\n\n  /**\n   * Enriches declared extensions using registered extension hooks.\n   *\n   * @param declaredExtensions - Extensions declared on the route\n   * @param transportContext - Transport-specific context (HTTP, A2A, MCP, etc.)\n   * @returns Enriched extensions map\n   */\n  enrichExtensions(\n    declaredExtensions: Record<string, unknown>,\n    transportContext: unknown,\n  ): Record<string, unknown> {\n    const enriched: Record<string, unknown> = {};\n\n    for (const [key, declaration] of Object.entries(declaredExtensions)) {\n      const extension = this.registeredExtensions.get(key);\n\n      if (extension?.enrichDeclaration) {\n        enriched[key] = extension.enrichDeclaration(declaration, transportContext);\n      } else {\n        enriched[key] = declaration;\n      }\n    }\n\n    return enriched;\n  }\n\n  /**\n   * Register a hook to execute before payment verification.\n   * Can abort verification by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeVerify(hook: BeforeVerifyHook): x402ResourceServer {\n    this.beforeVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment verification.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterVerify(hook: AfterVerifyHook): x402ResourceServer {\n    this.afterVerifyHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment verification fails.\n   * Can recover from failure by returning { recovered: true, result: VerifyResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onVerifyFailure(hook: OnVerifyFailureHook): x402ResourceServer {\n    this.onVerifyFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before payment settlement.\n   * Can abort settlement by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onBeforeSettle(hook: BeforeSettleHook): x402ResourceServer {\n    this.beforeSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment settlement.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onAfterSettle(hook: AfterSettleHook): x402ResourceServer {\n    this.afterSettleHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment settlement fails.\n   * Can recover from failure by returning { recovered: true, result: SettleResponse }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402ResourceServer instance for chaining\n   */\n  onSettleFailure(hook: OnSettleFailureHook): x402ResourceServer {\n    this.onSettleFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Initialize by fetching supported kinds from all facilitators\n   * Creates mappings for supported responses and facilitator clients\n   * Earlier facilitators in the array get precedence\n   */\n  async initialize(): Promise<void> {\n    // Clear existing mappings\n    this.supportedResponsesMap.clear();\n    this.facilitatorClientsMap.clear();\n\n    // Fetch supported kinds from all facilitator clients\n    // Process in order to give precedence to earlier facilitators\n    for (const facilitatorClient of this.facilitatorClients) {\n      try {\n        const supported = await facilitatorClient.getSupported();\n\n        // Process each supported kind (now flat array with version in each element)\n        for (const kind of supported.kinds) {\n          const x402Version = kind.x402Version;\n\n          // Get or create version map for supported responses\n          if (!this.supportedResponsesMap.has(x402Version)) {\n            this.supportedResponsesMap.set(x402Version, new Map());\n          }\n          const responseVersionMap = this.supportedResponsesMap.get(x402Version)!;\n\n          // Get or create version map for facilitator clients\n          if (!this.facilitatorClientsMap.has(x402Version)) {\n            this.facilitatorClientsMap.set(x402Version, new Map());\n          }\n          const clientVersionMap = this.facilitatorClientsMap.get(x402Version)!;\n\n          // Get or create network map for responses\n          if (!responseVersionMap.has(kind.network)) {\n            responseVersionMap.set(kind.network, new Map());\n          }\n          const responseNetworkMap = responseVersionMap.get(kind.network)!;\n\n          // Get or create network map for clients\n          if (!clientVersionMap.has(kind.network)) {\n            clientVersionMap.set(kind.network, new Map());\n          }\n          const clientNetworkMap = clientVersionMap.get(kind.network)!;\n\n          // Only store if not already present (gives precedence to earlier facilitators)\n          if (!responseNetworkMap.has(kind.scheme)) {\n            responseNetworkMap.set(kind.scheme, supported);\n            clientNetworkMap.set(kind.scheme, facilitatorClient);\n          }\n        }\n      } catch (error) {\n        // Log error but continue with other facilitators\n        console.warn(`Failed to fetch supported kinds from facilitator: ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Get supported kind for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The supported kind or undefined if not found\n   */\n  getSupportedKind(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): SupportedKind | undefined {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    if (!supportedResponse) return undefined;\n\n    // Find the specific kind from the response (kinds are flat array with version in each element)\n    return supportedResponse.kinds.find(\n      kind =>\n        kind.x402Version === x402Version && kind.network === network && kind.scheme === scheme,\n    );\n  }\n\n  /**\n   * Get facilitator extensions for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator extensions or empty array if not found\n   */\n  getFacilitatorExtensions(x402Version: number, network: Network, scheme: string): string[] {\n    const versionMap = this.supportedResponsesMap.get(x402Version);\n    if (!versionMap) return [];\n\n    const supportedResponse = findByNetworkAndScheme(versionMap, scheme, network);\n    return supportedResponse?.extensions || [];\n  }\n\n  /**\n   * Build payment requirements for a protected resource\n   *\n   * @param resourceConfig - Configuration for the protected resource\n   * @returns Array of payment requirements\n   */\n  async buildPaymentRequirements(resourceConfig: ResourceConfig): Promise<PaymentRequirements[]> {\n    const requirements: PaymentRequirements[] = [];\n\n    // Find the matching server implementation\n    const scheme = resourceConfig.scheme;\n    const SchemeNetworkServer = findByNetworkAndScheme(\n      this.registeredServerSchemes,\n      scheme,\n      resourceConfig.network,\n    );\n\n    if (!SchemeNetworkServer) {\n      // Fallback to placeholder implementation if no server registered\n      // TODO: Remove this fallback once implementations are registered\n      console.warn(\n        `No server implementation registered for scheme: ${scheme}, network: ${resourceConfig.network}`,\n      );\n      return requirements;\n    }\n\n    // Find the matching supported kind from facilitator\n    const supportedKind = this.getSupportedKind(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    if (!supportedKind) {\n      throw new Error(\n        `Facilitator does not support ${SchemeNetworkServer.scheme} on ${resourceConfig.network}. ` +\n          `Make sure to call initialize() to fetch supported kinds from facilitators.`,\n      );\n    }\n\n    // Get facilitator extensions for this combination\n    const facilitatorExtensions = this.getFacilitatorExtensions(\n      x402Version,\n      resourceConfig.network,\n      SchemeNetworkServer.scheme,\n    );\n\n    // Parse the price using the scheme's price parser\n    const parsedPrice = await SchemeNetworkServer.parsePrice(\n      resourceConfig.price,\n      resourceConfig.network,\n    );\n\n    // Build base payment requirements from resource config\n    const baseRequirements: PaymentRequirements = {\n      scheme: SchemeNetworkServer.scheme,\n      network: resourceConfig.network,\n      amount: parsedPrice.amount,\n      asset: parsedPrice.asset,\n      payTo: resourceConfig.payTo,\n      maxTimeoutSeconds: resourceConfig.maxTimeoutSeconds || 300, // Default 5 minutes\n      extra: {\n        ...parsedPrice.extra,\n      },\n    };\n\n    // Delegate to the implementation for scheme-specific enhancements\n    // Note: enhancePaymentRequirements expects x402Version in the kind, so we add it back\n    const requirement = await SchemeNetworkServer.enhancePaymentRequirements(\n      baseRequirements,\n      {\n        ...supportedKind,\n        x402Version,\n      },\n      facilitatorExtensions,\n    );\n\n    requirements.push(requirement);\n    return requirements;\n  }\n\n  /**\n   * Build payment requirements from multiple payment options\n   * This method handles resolving dynamic payTo/price functions and builds requirements for each option\n   *\n   * @param paymentOptions - Array of payment options to convert\n   * @param context - HTTP request context for resolving dynamic functions\n   * @returns Array of payment requirements (one per option)\n   */\n  async buildPaymentRequirementsFromOptions<TContext = unknown>(\n    paymentOptions: Array<{\n      scheme: string;\n      payTo: string | ((context: TContext) => string | Promise<string>);\n      price: Price | ((context: TContext) => Price | Promise<Price>);\n      network: Network;\n      maxTimeoutSeconds?: number;\n    }>,\n    context: TContext,\n  ): Promise<PaymentRequirements[]> {\n    const allRequirements: PaymentRequirements[] = [];\n\n    for (const option of paymentOptions) {\n      // Resolve dynamic payTo and price if they are functions\n      const resolvedPayTo =\n        typeof option.payTo === \"function\" ? await option.payTo(context) : option.payTo;\n      const resolvedPrice =\n        typeof option.price === \"function\" ? await option.price(context) : option.price;\n\n      const resourceConfig: ResourceConfig = {\n        scheme: option.scheme,\n        payTo: resolvedPayTo,\n        price: resolvedPrice,\n        network: option.network,\n        maxTimeoutSeconds: option.maxTimeoutSeconds,\n      };\n\n      // Use existing buildPaymentRequirements for each option\n      const requirements = await this.buildPaymentRequirements(resourceConfig);\n      allRequirements.push(...requirements);\n    }\n\n    return allRequirements;\n  }\n\n  /**\n   * Create a payment required response\n   *\n   * @param requirements - Payment requirements\n   * @param resourceInfo - Resource information\n   * @param error - Error message\n   * @param extensions - Optional extensions\n   * @returns Payment required response object\n   */\n  createPaymentRequiredResponse(\n    requirements: PaymentRequirements[],\n    resourceInfo: ResourceInfo,\n    error?: string,\n    extensions?: Record<string, unknown>,\n  ): PaymentRequired {\n    // V2 response with resource at top level\n    const response: PaymentRequired = {\n      x402Version: 2,\n      error,\n      resource: resourceInfo,\n      accepts: requirements as PaymentRequirements[],\n    };\n\n    // Add extensions if provided\n    if (extensions && Object.keys(extensions).length > 0) {\n      response.extensions = extensions;\n    }\n\n    return response;\n  }\n\n  /**\n   * Verify a payment against requirements\n   *\n   * @param paymentPayload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Verification response\n   */\n  async verifyPayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const context: VerifyContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeVerify hooks\n    for (const hook of this.beforeVerifyHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        return {\n          isValid: false,\n          invalidReason: result.reason,\n        };\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let verifyResult: VerifyResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            verifyResult = await client.verify(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!verifyResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        verifyResult = await facilitatorClient.verify(paymentPayload, requirements);\n      }\n\n      // Execute afterVerify hooks\n      const resultContext: VerifyResultContext = {\n        ...context,\n        result: verifyResult,\n      };\n\n      for (const hook of this.afterVerifyHooks) {\n        await hook(resultContext);\n      }\n\n      return verifyResult;\n    } catch (error) {\n      const failureContext: VerifyFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onVerifyFailure hooks\n      for (const hook of this.onVerifyFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Settle a verified payment\n   *\n   * @param paymentPayload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Settlement response\n   */\n  async settlePayment(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const context: SettleContext = {\n      paymentPayload,\n      requirements,\n    };\n\n    // Execute beforeSettle hooks\n    for (const hook of this.beforeSettleHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        throw new Error(`Settlement aborted: ${result.reason}`);\n      }\n    }\n\n    try {\n      // Find the facilitator that supports this payment type\n      const facilitatorClient = this.getFacilitatorClient(\n        paymentPayload.x402Version,\n        requirements.network,\n        requirements.scheme,\n      );\n\n      let settleResult: SettleResponse;\n\n      if (!facilitatorClient) {\n        // Fallback: try all facilitators if no specific support found\n        let lastError: Error | undefined;\n\n        for (const client of this.facilitatorClients) {\n          try {\n            settleResult = await client.settle(paymentPayload, requirements);\n            break;\n          } catch (error) {\n            lastError = error as Error;\n          }\n        }\n\n        if (!settleResult!) {\n          throw (\n            lastError ||\n            new Error(\n              `No facilitator supports ${requirements.scheme} on ${requirements.network} for v${paymentPayload.x402Version}`,\n            )\n          );\n        }\n      } else {\n        // Use the specific facilitator that supports this payment\n        settleResult = await facilitatorClient.settle(paymentPayload, requirements);\n      }\n\n      // Execute afterSettle hooks\n      const resultContext: SettleResultContext = {\n        ...context,\n        result: settleResult,\n      };\n\n      for (const hook of this.afterSettleHooks) {\n        await hook(resultContext);\n      }\n\n      return settleResult;\n    } catch (error) {\n      const failureContext: SettleFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onSettleFailure hooks\n      for (const hook of this.onSettleFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.result;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Find matching payment requirements for a payment\n   *\n   * @param availableRequirements - Array of available payment requirements\n   * @param paymentPayload - The payment payload\n   * @returns Matching payment requirements or undefined\n   */\n  findMatchingRequirements(\n    availableRequirements: PaymentRequirements[],\n    paymentPayload: PaymentPayload,\n  ): PaymentRequirements | undefined {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        // For v2, match by accepted requirements\n        return availableRequirements.find(paymentRequirements =>\n          deepEqual(paymentRequirements, paymentPayload.accepted),\n        );\n      case 1:\n        // For v1, match by scheme and network\n        return availableRequirements.find(\n          req =>\n            req.scheme === paymentPayload.accepted.scheme &&\n            req.network === paymentPayload.accepted.network,\n        );\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Process a payment request\n   *\n   * @param paymentPayload - Optional payment payload if provided\n   * @param resourceConfig - Configuration for the protected resource\n   * @param resourceInfo - Information about the resource being accessed\n   * @param extensions - Optional extensions to include in the response\n   * @returns Processing result\n   */\n  async processPaymentRequest(\n    paymentPayload: PaymentPayload | null,\n    resourceConfig: ResourceConfig,\n    resourceInfo: ResourceInfo,\n    extensions?: Record<string, unknown>,\n  ): Promise<{\n    success: boolean;\n    requiresPayment?: PaymentRequired;\n    verificationResult?: VerifyResponse;\n    settlementResult?: SettleResponse;\n    error?: string;\n  }> {\n    const requirements = await this.buildPaymentRequirements(resourceConfig);\n\n    if (!paymentPayload) {\n      return {\n        success: false,\n        requiresPayment: this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"Payment required\",\n          extensions,\n        ),\n      };\n    }\n\n    // Find matching requirements\n    const matchingRequirements = this.findMatchingRequirements(requirements, paymentPayload);\n    if (!matchingRequirements) {\n      return {\n        success: false,\n        requiresPayment: this.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements found\",\n          extensions,\n        ),\n      };\n    }\n\n    // Verify payment\n    const verificationResult = await this.verifyPayment(paymentPayload, matchingRequirements);\n    if (!verificationResult.isValid) {\n      return {\n        success: false,\n        error: verificationResult.invalidReason,\n        verificationResult,\n      };\n    }\n\n    // Payment verified, ready for settlement\n    return {\n      success: true,\n      verificationResult,\n    };\n  }\n\n  /**\n   * Get facilitator client for a specific version, network, and scheme\n   *\n   * @param x402Version - The x402 version\n   * @param network - The network identifier\n   * @param scheme - The payment scheme\n   * @returns The facilitator client or undefined if not found\n   */\n  private getFacilitatorClient(\n    x402Version: number,\n    network: Network,\n    scheme: string,\n  ): FacilitatorClient | undefined {\n    const versionMap = this.facilitatorClientsMap.get(x402Version);\n    if (!versionMap) return undefined;\n\n    // Use findByNetworkAndScheme for pattern matching\n    return findByNetworkAndScheme(versionMap, scheme, network);\n  }\n}\n\nexport default x402ResourceServer;\n"],"names":["x402Version"],"mappings":"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"}},
    {"offset": {"line": 1284, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/mechanisms/evm/src/exact/server/scheme.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/mechanisms/evm/src/exact/server/register.ts"],"sourcesContent":["import {\n  AssetAmount,\n  Network,\n  PaymentRequirements,\n  Price,\n  SchemeNetworkServer,\n  MoneyParser,\n} from \"@x402/core/types\";\n\n/**\n * EVM server implementation for the Exact payment scheme.\n */\nexport class ExactEvmScheme implements SchemeNetworkServer {\n  readonly scheme = \"exact\";\n  private moneyParsers: MoneyParser[] = [];\n\n  /**\n   * Register a custom money parser in the parser chain.\n   * Multiple parsers can be registered - they will be tried in registration order.\n   * Each parser receives a decimal amount (e.g., 1.50 for $1.50).\n   * If a parser returns null, the next parser in the chain will be tried.\n   * The default parser is always the final fallback.\n   *\n   * @param parser - Custom function to convert amount to AssetAmount (or null to skip)\n   * @returns The server instance for chaining\n   *\n   * @example\n   * evmServer.registerMoneyParser(async (amount, network) => {\n   *   // Custom conversion logic\n   *   if (amount > 100) {\n   *     // Use different token for large amounts\n   *     return { amount: (amount * 1e18).toString(), asset: \"0xCustomToken\" };\n   *   }\n   *   return null; // Use next parser\n   * });\n   */\n  registerMoneyParser(parser: MoneyParser): ExactEvmScheme {\n    this.moneyParsers.push(parser);\n    return this;\n  }\n\n  /**\n   * Parses a price into an asset amount.\n   * If price is already an AssetAmount, returns it directly.\n   * If price is Money (string | number), parses to decimal and tries custom parsers.\n   * Falls back to default conversion if all custom parsers return null.\n   *\n   * @param price - The price to parse\n   * @param network - The network to use\n   * @returns Promise that resolves to the parsed asset amount\n   */\n  async parsePrice(price: Price, network: Network): Promise<AssetAmount> {\n    // If already an AssetAmount, return it directly\n    if (typeof price === \"object\" && price !== null && \"amount\" in price) {\n      if (!price.asset) {\n        throw new Error(`Asset address must be specified for AssetAmount on network ${network}`);\n      }\n      return {\n        amount: price.amount,\n        asset: price.asset,\n        extra: price.extra || {},\n      };\n    }\n\n    // Parse Money to decimal number\n    const amount = this.parseMoneyToDecimal(price);\n\n    // Try each custom money parser in order\n    for (const parser of this.moneyParsers) {\n      const result = await parser(amount, network);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    // All custom parsers returned null, use default conversion\n    return this.defaultMoneyConversion(amount, network);\n  }\n\n  /**\n   * Build payment requirements for this scheme/network combination\n   *\n   * @param paymentRequirements - The base payment requirements\n   * @param supportedKind - The supported kind from facilitator (unused)\n   * @param supportedKind.x402Version - The x402 version\n   * @param supportedKind.scheme - The logical payment scheme\n   * @param supportedKind.network - The network identifier in CAIP-2 format\n   * @param supportedKind.extra - Optional extra metadata regarding scheme/network implementation details\n   * @param extensionKeys - Extension keys supported by the facilitator (unused)\n   * @returns Payment requirements ready to be sent to clients\n   */\n  enhancePaymentRequirements(\n    paymentRequirements: PaymentRequirements,\n    supportedKind: {\n      x402Version: number;\n      scheme: string;\n      network: Network;\n      extra?: Record<string, unknown>;\n    },\n    extensionKeys: string[],\n  ): Promise<PaymentRequirements> {\n    // Mark unused parameters to satisfy linter\n    void supportedKind;\n    void extensionKeys;\n    return Promise.resolve(paymentRequirements);\n  }\n\n  /**\n   * Parse Money (string | number) to a decimal number.\n   * Handles formats like \"$1.50\", \"1.50\", 1.50, etc.\n   *\n   * @param money - The money value to parse\n   * @returns Decimal number\n   */\n  private parseMoneyToDecimal(money: string | number): number {\n    if (typeof money === \"number\") {\n      return money;\n    }\n\n    // Remove $ sign and whitespace, then parse\n    const cleanMoney = money.replace(/^\\$/, \"\").trim();\n    const amount = parseFloat(cleanMoney);\n\n    if (isNaN(amount)) {\n      throw new Error(`Invalid money format: ${money}`);\n    }\n\n    return amount;\n  }\n\n  /**\n   * Default money conversion implementation.\n   * Converts decimal amount to USDC on the specified network.\n   *\n   * @param amount - The decimal amount (e.g., 1.50)\n   * @param network - The network to use\n   * @returns The parsed asset amount in USDC\n   */\n  private defaultMoneyConversion(amount: number, network: Network): AssetAmount {\n    // Convert decimal amount to token amount (USDC has 6 decimals)\n    const tokenAmount = this.convertToTokenAmount(amount.toString(), network);\n    const assetInfo = this.getDefaultAsset(network);\n\n    return {\n      amount: tokenAmount,\n      asset: assetInfo.address,\n      extra: {\n        name: assetInfo.name,\n        version: assetInfo.version,\n      },\n    };\n  }\n\n  /**\n   * Convert decimal amount to token units (e.g., 0.10 -> 100000 for 6-decimal USDC)\n   *\n   * @param decimalAmount - The decimal amount to convert\n   * @param network - The network to use\n   * @returns The token amount as a string\n   */\n  private convertToTokenAmount(decimalAmount: string, network: Network): string {\n    const decimals = this.getAssetDecimals(network);\n    const amount = parseFloat(decimalAmount);\n    if (isNaN(amount)) {\n      throw new Error(`Invalid amount: ${decimalAmount}`);\n    }\n    // Convert to smallest unit (e.g., for USDC with 6 decimals: 0.10 * 10^6 = 100000)\n    const [intPart, decPart = \"\"] = String(amount).split(\".\");\n    const paddedDec = decPart.padEnd(decimals, \"0\").slice(0, decimals);\n    const tokenAmount = (intPart + paddedDec).replace(/^0+/, \"\") || \"0\";\n    return tokenAmount;\n  }\n\n  /**\n   * Get the default asset info for a network (typically USDC)\n   *\n   * @param network - The network to get asset info for\n   * @returns The asset information including address, name, and version\n   */\n  private getDefaultAsset(network: Network): { address: string; name: string; version: string } {\n    // Map of network to USDC info including EIP-712 domain parameters\n    const usdcInfo: Record<string, { address: string; name: string; version: string }> = {\n      \"eip155:8453\": {\n        address: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n        name: \"USD Coin\",\n        version: \"2\",\n      }, // Base mainnet USDC\n      \"eip155:84532\": {\n        address: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n        name: \"USDC\",\n        version: \"2\",\n      }, // Base Sepolia USDC\n      \"eip155:1\": {\n        address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n        name: \"USD Coin\",\n        version: \"2\",\n      }, // Ethereum mainnet USDC\n      \"eip155:11155111\": {\n        address: \"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238\",\n        name: \"USDC\",\n        version: \"2\",\n      }, // Sepolia USDC\n    };\n\n    const assetInfo = usdcInfo[network];\n    if (!assetInfo) {\n      throw new Error(`No default asset configured for network ${network}`);\n    }\n\n    return assetInfo;\n  }\n\n  /**\n   * Get asset info for a given symbol on a network\n   *\n   * @param symbol - The asset symbol\n   * @param network - The network to use\n   * @returns The asset information including address, name, and version\n   */\n  private getAssetInfo(\n    symbol: string,\n    network: Network,\n  ): { address: string; name: string; version: string } {\n    const upperSymbol = symbol.toUpperCase();\n\n    // For now, only support USDC\n    if (upperSymbol === \"USDC\" || upperSymbol === \"USD\") {\n      return this.getDefaultAsset(network);\n    }\n\n    // Could extend to support other tokens\n    throw new Error(`Unsupported asset: ${symbol} on network ${network}`);\n  }\n\n  /**\n   * Get the number of decimals for the asset\n   *\n   * @param _ - The network to use (unused)\n   * @returns The number of decimals for the asset\n   */\n  private getAssetDecimals(_: Network): number {\n    // USDC has 6 decimals on all EVM chains\n    return 6;\n  }\n}\n","import { x402ResourceServer } from \"@x402/core/server\";\nimport { Network } from \"@x402/core/types\";\nimport { ExactEvmScheme } from \"./scheme\";\n\n/**\n * Configuration options for registering EVM schemes to an x402ResourceServer\n */\nexport interface EvmResourceServerConfig {\n  /**\n   * Optional specific networks to register\n   * If not provided, registers wildcard support (eip155:*)\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers EVM exact payment schemes to an x402ResourceServer instance.\n *\n * This function registers:\n * - V2: eip155:* wildcard scheme with ExactEvmScheme (or specific networks if provided)\n *\n * @param server - The x402ResourceServer instance to register schemes to\n * @param config - Configuration for EVM resource server registration\n * @returns The server instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/server/register\";\n * import { x402ResourceServer } from \"@x402/core/server\";\n *\n * const server = new x402ResourceServer(facilitatorClient);\n * registerExactEvmScheme(server, {});\n * ```\n */\nexport function registerExactEvmScheme(\n  server: x402ResourceServer,\n  config: EvmResourceServerConfig = {},\n): x402ResourceServer {\n  // Register V2 scheme\n  if (config.networks && config.networks.length > 0) {\n    // Register specific networks\n    config.networks.forEach(network => {\n      server.register(network, new ExactEvmScheme());\n    });\n  } else {\n    // Register wildcard for all EVM chains\n    server.register(\"eip155:*\", new ExactEvmScheme());\n  }\n\n  return server;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1493, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/mechanisms/svm/src/constants.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/mechanisms/svm/src/utils.ts"],"sourcesContent":["/**\n * Token program addresses for SPL Token and Token-2022\n * These addresses are the same across all Solana networks (mainnet, devnet, testnet)\n */\nexport const TOKEN_PROGRAM_ADDRESS = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\nexport const TOKEN_2022_PROGRAM_ADDRESS = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS = \"ComputeBudget111111111111111111111111111111\";\n\n/**\n * Default RPC URLs for Solana networks\n */\nexport const DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\nexport const TESTNET_RPC_URL = \"https://api.testnet.solana.com\";\nexport const MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\nexport const DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\nexport const TESTNET_WS_URL = \"wss://api.testnet.solana.com\";\nexport const MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * USDC token mint addresses (default stablecoin)\n */\nexport const USDC_MAINNET_ADDRESS = \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\";\nexport const USDC_DEVNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\";\nexport const USDC_TESTNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\"; // Same as devnet\n\n/**\n * Compute budget configuration\n * All prices are in microlamports (1 lamport = 1,000,000 microlamports)\n */\nexport const DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 1;\nexport const MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 5_000_000; // 5 lamports\nexport const DEFAULT_COMPUTE_UNIT_LIMIT = 6500;\n\n/**\n * Solana address validation regex (base58, 32-44 characters)\n */\nexport const SVM_ADDRESS_REGEX = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n\n/**\n * CAIP-2 network identifiers for Solana (V2)\n */\nexport const SOLANA_MAINNET_CAIP2 = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\nexport const SOLANA_DEVNET_CAIP2 = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\nexport const SOLANA_TESTNET_CAIP2 = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n\n/**\n * V1 to V2 network identifier mappings (for backwards compatibility)\n * V1 used simple names like solana, V2 uses CAIP-2\n */\nexport const V1_TO_V2_NETWORK_MAP: Record<string, string> = {\n  solana: SOLANA_MAINNET_CAIP2,\n  \"solana-devnet\": SOLANA_DEVNET_CAIP2,\n  \"solana-testnet\": SOLANA_TESTNET_CAIP2,\n};\n","import {\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type Transaction,\n  type CompiledTransactionMessage,\n  createSolanaRpc,\n  devnet,\n  testnet,\n  mainnet,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcTestnet,\n  type SolanaRpcApiTestnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type { Network } from \"@x402/core/types\";\nimport {\n  SVM_ADDRESS_REGEX,\n  DEVNET_RPC_URL,\n  TESTNET_RPC_URL,\n  MAINNET_RPC_URL,\n  USDC_MAINNET_ADDRESS,\n  USDC_DEVNET_ADDRESS,\n  USDC_TESTNET_ADDRESS,\n  SOLANA_MAINNET_CAIP2,\n  SOLANA_DEVNET_CAIP2,\n  SOLANA_TESTNET_CAIP2,\n  V1_TO_V2_NETWORK_MAP,\n} from \"./constants\";\nimport type { ExactSvmPayloadV1 } from \"./types\";\n\n/**\n * Normalize network identifier to CAIP-2 format\n * Handles both V1 names (solana, solana-devnet) and V2 CAIP-2 format\n *\n * @param network - Network identifier (V1 or V2 format)\n * @returns CAIP-2 network identifier\n */\nexport function normalizeNetwork(network: Network): string {\n  // If it's already CAIP-2 format (contains \":\"), validate it's supported\n  if (network.includes(\":\")) {\n    const supported = [SOLANA_MAINNET_CAIP2, SOLANA_DEVNET_CAIP2, SOLANA_TESTNET_CAIP2];\n    if (!supported.includes(network)) {\n      throw new Error(`Unsupported SVM network: ${network}`);\n    }\n    return network;\n  }\n\n  // Otherwise, it's a V1 network name, convert to CAIP-2\n  const caip2Network = V1_TO_V2_NETWORK_MAP[network];\n  if (!caip2Network) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return caip2Network;\n}\n\n/**\n * Validate Solana address format\n *\n * @param address - Base58 encoded address string\n * @returns true if address is valid, false otherwise\n */\nexport function validateSvmAddress(address: string): boolean {\n  return SVM_ADDRESS_REGEX.test(address);\n}\n\n/**\n * Decode a base64 encoded transaction from an SVM payload\n *\n * @param svmPayload - The SVM payload containing a base64 encoded transaction\n * @returns Decoded Transaction object\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayloadV1): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"Error decoding transaction:\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account) from a TransferChecked instruction\n *\n * @param transaction - The decoded transaction\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes,\n  ) as CompiledTransactionMessage;\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n\n    // Check if this is a token program instruction\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      // TransferChecked account order: [source, mint, destination, owner, ...]\n      if (accountIndices.length >= 4) {\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Create an RPC client for the specified network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @param customRpcUrl - Optional custom RPC URL\n * @returns RPC client for the specified network\n */\nexport function createRpcClient(\n  network: Network,\n  customRpcUrl?: string,\n):\n  | RpcDevnet<SolanaRpcApiDevnet>\n  | RpcTestnet<SolanaRpcApiTestnet>\n  | RpcMainnet<SolanaRpcApiMainnet> {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_DEVNET_CAIP2: {\n      const url = customRpcUrl || DEVNET_RPC_URL;\n      return createSolanaRpc(devnet(url)) as RpcDevnet<SolanaRpcApiDevnet>;\n    }\n    case SOLANA_TESTNET_CAIP2: {\n      const url = customRpcUrl || TESTNET_RPC_URL;\n      return createSolanaRpc(testnet(url)) as RpcTestnet<SolanaRpcApiTestnet>;\n    }\n    case SOLANA_MAINNET_CAIP2: {\n      const url = customRpcUrl || MAINNET_RPC_URL;\n      return createSolanaRpc(mainnet(url)) as RpcMainnet<SolanaRpcApiMainnet>;\n    }\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\n/**\n * Get the default USDC mint address for a network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @returns USDC mint address for the network\n */\nexport function getUsdcAddress(network: Network): string {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_MAINNET_CAIP2:\n      return USDC_MAINNET_ADDRESS;\n    case SOLANA_DEVNET_CAIP2:\n      return USDC_DEVNET_ADDRESS;\n    case SOLANA_TESTNET_CAIP2:\n      return USDC_TESTNET_ADDRESS;\n    default:\n      throw new Error(`No USDC address configured for network: ${network}`);\n  }\n}\n\n/**\n * Convert a decimal amount to token smallest units\n *\n * @param decimalAmount - The decimal amount (e.g., \"0.10\")\n * @param decimals - The number of decimals for the token (e.g., 6 for USDC)\n * @returns The amount in smallest units as a string\n */\nexport function convertToTokenAmount(decimalAmount: string, decimals: number): string {\n  const amount = parseFloat(decimalAmount);\n  if (isNaN(amount)) {\n    throw new Error(`Invalid amount: ${decimalAmount}`);\n  }\n  // Convert to smallest unit (e.g., for USDC with 6 decimals: 0.10 * 10^6 = 100000)\n  const [intPart, decPart = \"\"] = String(amount).split(\".\");\n  const paddedDec = decPart.padEnd(decimals, \"0\").slice(0, decimals);\n  const tokenAmount = (intPart + paddedDec).replace(/^0+/, \"\") || \"0\";\n  return tokenAmount;\n}\n"],"names":["TOKEN_PROGRAM_ADDRESS","TOKEN_2022_PROGRAM_ADDRESS","TOKEN_PROGRAM_ADDRESS","TOKEN_2022_PROGRAM_ADDRESS"],"mappings":"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"}},
    {"offset": {"line": 1686, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/mechanisms/svm/src/exact/server/scheme.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/mechanisms/svm/src/exact/server/register.ts"],"sourcesContent":["import type {\n  AssetAmount,\n  Network,\n  PaymentRequirements,\n  Price,\n  SchemeNetworkServer,\n  MoneyParser,\n} from \"@x402/core/types\";\nimport { convertToTokenAmount, getUsdcAddress } from \"../../utils\";\n\n/**\n * SVM server implementation for the Exact payment scheme.\n */\nexport class ExactSvmScheme implements SchemeNetworkServer {\n  readonly scheme = \"exact\";\n  private moneyParsers: MoneyParser[] = [];\n\n  /**\n   * Register a custom money parser in the parser chain.\n   * Multiple parsers can be registered - they will be tried in registration order.\n   * Each parser receives a decimal amount (e.g., 1.50 for $1.50).\n   * If a parser returns null, the next parser in the chain will be tried.\n   * The default parser is always the final fallback.\n   *\n   * @param parser - Custom function to convert amount to AssetAmount (or null to skip)\n   * @returns The service instance for chaining\n   */\n  registerMoneyParser(parser: MoneyParser): ExactSvmScheme {\n    this.moneyParsers.push(parser);\n    return this;\n  }\n\n  /**\n   * Parses a price into an asset amount.\n   * If price is already an AssetAmount, returns it directly.\n   * If price is Money (string | number), parses to decimal and tries custom parsers.\n   * Falls back to default conversion if all custom parsers return null.\n   *\n   * @param price - The price to parse\n   * @param network - The network to use\n   * @returns Promise that resolves to the parsed asset amount\n   */\n  async parsePrice(price: Price, network: Network): Promise<AssetAmount> {\n    // If already an AssetAmount, return it directly\n    if (typeof price === \"object\" && price !== null && \"amount\" in price) {\n      if (!price.asset) {\n        throw new Error(`Asset address must be specified for AssetAmount on network ${network}`);\n      }\n      return {\n        amount: price.amount,\n        asset: price.asset,\n        extra: price.extra || {},\n      };\n    }\n\n    // Parse Money to decimal number\n    const amount = this.parseMoneyToDecimal(price);\n\n    // Try each custom money parser in order\n    for (const parser of this.moneyParsers) {\n      const result = await parser(amount, network);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    // All custom parsers returned null, use default conversion\n    return this.defaultMoneyConversion(amount, network);\n  }\n\n  /**\n   * Build payment requirements for this scheme/network combination\n   *\n   * @param paymentRequirements - The base payment requirements\n   * @param supportedKind - The supported kind configuration\n   * @param supportedKind.x402Version - The x402 protocol version\n   * @param supportedKind.scheme - The payment scheme\n   * @param supportedKind.network - The network identifier\n   * @param supportedKind.extra - Extra metadata including feePayer address\n   * @param extensionKeys - Extension keys supported by the facilitator\n   * @returns Enhanced payment requirements with feePayer in extra\n   */\n  enhancePaymentRequirements(\n    paymentRequirements: PaymentRequirements,\n    supportedKind: {\n      x402Version: number;\n      scheme: string;\n      network: Network;\n      extra?: Record<string, unknown>;\n    },\n    extensionKeys: string[],\n  ): Promise<PaymentRequirements> {\n    // Mark unused parameters to satisfy linter\n    void extensionKeys;\n\n    // Add feePayer from supportedKind.extra to payment requirements\n    // The facilitator provides its address as the fee payer for transaction fees\n    return Promise.resolve({\n      ...paymentRequirements,\n      extra: {\n        ...paymentRequirements.extra,\n        feePayer: supportedKind.extra?.feePayer,\n      },\n    });\n  }\n\n  /**\n   * Parse Money (string | number) to a decimal number.\n   * Handles formats like \"$1.50\", \"1.50\", 1.50, etc.\n   *\n   * @param money - The money value to parse\n   * @returns Decimal number\n   */\n  private parseMoneyToDecimal(money: string | number): number {\n    if (typeof money === \"number\") {\n      return money;\n    }\n\n    // Remove $ sign and whitespace, then parse\n    const cleanMoney = money.replace(/^\\$/, \"\").trim();\n    const amount = parseFloat(cleanMoney);\n\n    if (isNaN(amount)) {\n      throw new Error(`Invalid money format: ${money}`);\n    }\n\n    return amount;\n  }\n\n  /**\n   * Default money conversion implementation.\n   * Converts decimal amount to USDC on the specified network.\n   *\n   * @param amount - The decimal amount (e.g., 1.50)\n   * @param network - The network to use\n   * @returns The parsed asset amount in USDC\n   */\n  private defaultMoneyConversion(amount: number, network: Network): AssetAmount {\n    // Convert decimal amount to token amount (USDC has 6 decimals)\n    const tokenAmount = convertToTokenAmount(amount.toString(), 6);\n\n    return {\n      amount: tokenAmount,\n      asset: getUsdcAddress(network),\n      extra: {},\n    };\n  }\n}\n","import { x402ResourceServer } from \"@x402/core/server\";\nimport { Network } from \"@x402/core/types\";\nimport { ExactSvmScheme } from \"./scheme\";\n\n/**\n * Configuration options for registering SVM schemes to an x402ResourceServer\n */\nexport interface SvmResourceServerConfig {\n  /**\n   * Optional specific networks to register\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers SVM payment schemes to an existing x402ResourceServer instance.\n *\n * @param server - The x402ResourceServer instance to register schemes to\n * @param config - Configuration for SVM resource server registration\n * @returns The server instance for chaining\n */\nexport function registerExactSvmScheme(\n  server: x402ResourceServer,\n  config: SvmResourceServerConfig = {},\n): x402ResourceServer {\n  if (config.networks && config.networks.length > 0) {\n    config.networks.forEach(network => {\n      server.register(network, new ExactSvmScheme());\n    });\n  } else {\n    server.register(\"solana:*\", new ExactSvmScheme());\n  }\n\n  return server;\n}\n"],"names":[],"mappings":";;;;;;;;;AAaO,IAAM,iBAAN,MAAoD;IAApD,aAAA;QACL,IAAA,CAAS,MAAA,GAAS;QAClB,IAAA,CAAQ,YAAA,GAA8B,CAAC,CAAA;IAAA;IAAA;;;;;;;;;GAAA,GAYvC,oBAAoB,MAAA,EAAqC;QACvD,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAM;QAC7B,OAAO,IAAA;IACT;IAAA;;;;;;;;;GAAA,GAYA,MAAM,WAAW,KAAA,EAAc,OAAA,EAAwC;QAErE,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY,OAAO;YACpE,IAAI,CAAC,MAAM,KAAA,EAAO;gBAChB,MAAM,IAAI,MAAM,CAAA,2DAAA,EAA8D,OAAO,EAAE;YACzF;YACA,OAAO;gBACL,QAAQ,MAAM,MAAA;gBACd,OAAO,MAAM,KAAA;gBACb,OAAO,MAAM,KAAA,IAAS,CAAC;YACzB;QACF;QAGA,MAAM,SAAS,IAAA,CAAK,mBAAA,CAAoB,KAAK;QAG7C,KAAA,MAAW,UAAU,IAAA,CAAK,YAAA,CAAc;YACtC,MAAM,SAAS,MAAM,OAAO,QAAQ,OAAO;YAC3C,IAAI,WAAW,MAAM;gBACnB,OAAO;YACT;QACF;QAGA,OAAO,IAAA,CAAK,sBAAA,CAAuB,QAAQ,OAAO;IACpD;IAAA;;;;;;;;;;;GAAA,GAcA,2BACE,mBAAA,EACA,aAAA,EAMA,aAAA,EAC8B;QAE9B,KAAK;QAIL,OAAO,QAAQ,OAAA,CAAQ;YACrB,GAAG,mBAAA;YACH,OAAO;gBACL,GAAG,oBAAoB,KAAA;gBACvB,UAAU,cAAc,KAAA,EAAO;YACjC;QACF,CAAC;IACH;IAAA;;;;;;GAAA,GASQ,oBAAoB,KAAA,EAAgC;QAC1D,IAAI,OAAO,UAAU,UAAU;YAC7B,OAAO;QACT;QAGA,MAAM,aAAa,MAAM,OAAA,CAAQ,OAAO,EAAE,EAAE,IAAA,CAAK;QACjD,MAAM,SAAS,WAAW,UAAU;QAEpC,IAAI,MAAM,MAAM,GAAG;YACjB,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyB,KAAK,EAAE;QAClD;QAEA,OAAO;IACT;IAAA;;;;;;;GAAA,GAUQ,uBAAuB,MAAA,EAAgB,OAAA,EAA+B;QAE5E,MAAM,kBAAc,wMAAA,EAAqB,OAAO,QAAA,CAAS,GAAG,CAAC;QAE7D,OAAO;YACL,QAAQ;YACR,WAAO,kMAAA,EAAe,OAAO;YAC7B,OAAO,CAAC;QACV;IACF;AACF;;AC9HO,SAAS,uBACd,MAAA,EACA,SAAkC,CAAC,CAAA,EACf;IACpB,IAAI,OAAO,QAAA,IAAY,OAAO,QAAA,CAAS,MAAA,GAAS,GAAG;QACjD,OAAO,QAAA,CAAS,OAAA,CAAQ,CAAA,YAAW;YACjC,OAAO,QAAA,CAAS,SAAS,IAAI,eAAe,CAAC;QAC/C,CAAC;IACH,OAAO;QACL,OAAO,QAAA,CAAS,YAAY,IAAI,eAAe,CAAC;IAClD;IAEA,OAAO;AACT"}},
    {"offset": {"line": 1813, "column": 0}, "map": {"version":3,"sources":["file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/extensions/src/bazaar/types.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/extensions/src/bazaar/resourceService.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/extensions/src/bazaar/server.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/extensions/src/bazaar/facilitator.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/extensions/src/bazaar/v1/facilitator.ts","file:///Users/morganpage/Documents/VSCODE/X402/x402/typescript/packages/extensions/src/bazaar/facilitatorClient.ts"],"sourcesContent":["/**\n * Type definitions for the Bazaar Discovery Extension\n */\n\nimport type { BodyMethods, QueryParamMethods } from \"@x402/core/http\";\n\n/**\n * Extension identifier constant for the Bazaar discovery extension\n */\nexport const BAZAAR = \"bazaar\";\n\n/**\n * Discovery info for query parameter methods (GET, HEAD, DELETE)\n */\nexport interface QueryDiscoveryInfo {\n  input: {\n    type: \"http\";\n    method: QueryParamMethods;\n    queryParams?: Record<string, unknown>;\n    headers?: Record<string, string>;\n  };\n  output?: {\n    type?: string;\n    format?: string;\n    example?: unknown;\n  };\n}\n\n/**\n * Discovery info for body methods (POST, PUT, PATCH)\n */\nexport interface BodyDiscoveryInfo {\n  input: {\n    type: \"http\";\n    method: BodyMethods;\n    bodyType: \"json\" | \"form-data\" | \"text\";\n    body: Record<string, unknown>;\n    queryParams?: Record<string, unknown>;\n    headers?: Record<string, string>;\n  };\n  output?: {\n    type?: string;\n    format?: string;\n    example?: unknown;\n  };\n}\n\n/**\n * Combined discovery info type\n */\nexport type DiscoveryInfo = QueryDiscoveryInfo | BodyDiscoveryInfo;\n\n/**\n * Discovery extension for query parameter methods (GET, HEAD, DELETE)\n */\nexport interface QueryDiscoveryExtension {\n  info: QueryDiscoveryInfo;\n\n  schema: {\n    $schema: \"https://json-schema.org/draft/2020-12/schema\";\n    type: \"object\";\n    properties: {\n      input: {\n        type: \"object\";\n        properties: {\n          type: {\n            type: \"string\";\n            const: \"http\";\n          };\n          method: {\n            type: \"string\";\n            enum: QueryParamMethods[];\n          };\n          queryParams?: {\n            type: \"object\";\n            properties?: Record<string, unknown>;\n            required?: string[];\n            additionalProperties?: boolean;\n          };\n          headers?: {\n            type: \"object\";\n            additionalProperties: {\n              type: \"string\";\n            };\n          };\n        };\n        required: (\"type\" | \"method\")[];\n        additionalProperties?: boolean;\n      };\n      output?: {\n        type: \"object\";\n        properties?: Record<string, unknown>;\n        required?: readonly string[];\n        additionalProperties?: boolean;\n      };\n    };\n    required: [\"input\"];\n  };\n}\n\n/**\n * Discovery extension for body methods (POST, PUT, PATCH)\n */\nexport interface BodyDiscoveryExtension {\n  info: BodyDiscoveryInfo;\n\n  schema: {\n    $schema: \"https://json-schema.org/draft/2020-12/schema\";\n    type: \"object\";\n    properties: {\n      input: {\n        type: \"object\";\n        properties: {\n          type: {\n            type: \"string\";\n            const: \"http\";\n          };\n          method: {\n            type: \"string\";\n            enum: BodyMethods[];\n          };\n          bodyType: {\n            type: \"string\";\n            enum: [\"json\", \"form-data\", \"text\"];\n          };\n          body: Record<string, unknown>;\n          queryParams?: {\n            type: \"object\";\n            properties?: Record<string, unknown>;\n            required?: string[];\n            additionalProperties?: boolean;\n          };\n          headers?: {\n            type: \"object\";\n            additionalProperties: {\n              type: \"string\";\n            };\n          };\n        };\n        required: (\"type\" | \"method\" | \"bodyType\" | \"body\")[];\n        additionalProperties?: boolean;\n      };\n      output?: {\n        type: \"object\";\n        properties?: Record<string, unknown>;\n        required?: readonly string[];\n        additionalProperties?: boolean;\n      };\n    };\n    required: [\"input\"];\n  };\n}\n\n/**\n * Combined discovery extension type\n */\nexport type DiscoveryExtension = QueryDiscoveryExtension | BodyDiscoveryExtension;\n\nexport interface DeclareQueryDiscoveryExtensionConfig {\n  method?: QueryParamMethods;\n  input?: Record<string, unknown>;\n  inputSchema?: Record<string, unknown>;\n  output?: {\n    example?: unknown;\n    schema?: Record<string, unknown>;\n  };\n}\n\nexport interface DeclareBodyDiscoveryExtensionConfig {\n  method?: BodyMethods;\n  input?: Record<string, unknown>;\n  inputSchema?: Record<string, unknown>;\n  bodyType?: \"json\" | \"form-data\" | \"text\";\n  output?: {\n    example?: unknown;\n    schema?: Record<string, unknown>;\n  };\n}\n\nexport type DeclareDiscoveryExtensionConfig =\n  | DeclareQueryDiscoveryExtensionConfig\n  | DeclareBodyDiscoveryExtensionConfig;\n\nexport const isQueryExtensionConfig = (\n  config: DeclareDiscoveryExtensionConfig,\n): config is DeclareQueryDiscoveryExtensionConfig => {\n  return !(\"bodyType\" in config);\n};\n\nexport const isBodyExtensionConfig = (\n  config: DeclareDiscoveryExtensionConfig,\n): config is DeclareBodyDiscoveryExtensionConfig => {\n  return \"bodyType\" in config;\n};\n","/**\n * Resource Service functions for creating Bazaar discovery extensions\n *\n * These functions help servers declare the shape of their endpoints\n * for facilitator discovery and cataloging in the Bazaar.\n */\n\nimport {\n  type DiscoveryExtension,\n  type QueryDiscoveryExtension,\n  type BodyDiscoveryExtension,\n  type DeclareDiscoveryExtensionConfig,\n  type DeclareQueryDiscoveryExtensionConfig,\n  type DeclareBodyDiscoveryExtensionConfig,\n} from \"./types\";\n\n/**\n * Internal helper to create a query discovery extension\n *\n * @param root0 - Configuration object for query discovery extension\n * @param root0.method - HTTP method (GET, HEAD, DELETE)\n * @param root0.input - Query parameters\n * @param root0.inputSchema - JSON schema for query parameters\n * @param root0.output - Output specification with example\n * @returns QueryDiscoveryExtension with info and schema\n */\nfunction createQueryDiscoveryExtension({\n  method,\n  input = {},\n  inputSchema = { properties: {} },\n  output,\n}: DeclareQueryDiscoveryExtensionConfig): QueryDiscoveryExtension {\n  return {\n    info: {\n      input: {\n        type: \"http\",\n        ...(method ? { method } : {}),\n        ...(input ? { queryParams: input } : {}),\n      } as QueryDiscoveryExtension[\"info\"][\"input\"],\n      ...(output?.example\n        ? {\n            output: {\n              type: \"json\",\n              example: output.example,\n            },\n          }\n        : {}),\n    },\n    schema: {\n      $schema: \"https://json-schema.org/draft/2020-12/schema\",\n      type: \"object\",\n      properties: {\n        input: {\n          type: \"object\",\n          properties: {\n            type: {\n              type: \"string\",\n              const: \"http\",\n            },\n            method: {\n              type: \"string\",\n              enum: [\"GET\", \"HEAD\", \"DELETE\"],\n            },\n            ...(inputSchema\n              ? {\n                  queryParams: {\n                    type: \"object\" as const,\n                    ...(typeof inputSchema === \"object\" ? inputSchema : {}),\n                  },\n                }\n              : {}),\n          },\n          required: [\"type\"] as (\"type\" | \"method\")[],\n          additionalProperties: false,\n        },\n        ...(output?.example\n          ? {\n              output: {\n                type: \"object\" as const,\n                properties: {\n                  type: {\n                    type: \"string\" as const,\n                  },\n                  example: {\n                    type: \"object\" as const,\n                    ...(output.schema && typeof output.schema === \"object\" ? output.schema : {}),\n                  },\n                },\n                required: [\"type\"] as const,\n              },\n            }\n          : {}),\n      },\n      required: [\"input\"],\n    },\n  };\n}\n\n/**\n * Internal helper to create a body discovery extension\n *\n * @param root0 - Configuration object for body discovery extension\n * @param root0.method - HTTP method (POST, PUT, PATCH)\n * @param root0.input - Request body specification\n * @param root0.inputSchema - JSON schema for request body\n * @param root0.bodyType - Content type of body (json, form, multipart)\n * @param root0.output - Output specification with example\n * @returns BodyDiscoveryExtension with info and schema\n */\nfunction createBodyDiscoveryExtension({\n  method,\n  input = {},\n  inputSchema = { properties: {} },\n  bodyType = \"json\",\n  output,\n}: DeclareBodyDiscoveryExtensionConfig): BodyDiscoveryExtension {\n  return {\n    info: {\n      input: {\n        type: \"http\",\n        ...(method ? { method } : {}),\n        bodyType,\n        body: input,\n      } as BodyDiscoveryExtension[\"info\"][\"input\"],\n      ...(output?.example\n        ? {\n            output: {\n              type: \"json\",\n              example: output.example,\n            },\n          }\n        : {}),\n    },\n    schema: {\n      $schema: \"https://json-schema.org/draft/2020-12/schema\",\n      type: \"object\",\n      properties: {\n        input: {\n          type: \"object\",\n          properties: {\n            type: {\n              type: \"string\",\n              const: \"http\",\n            },\n            method: {\n              type: \"string\",\n              enum: [\"POST\", \"PUT\", \"PATCH\"],\n            },\n            bodyType: {\n              type: \"string\",\n              enum: [\"json\", \"form-data\", \"text\"],\n            },\n            body: inputSchema,\n          },\n          required: [\"type\", \"bodyType\", \"body\"] as (\"type\" | \"method\" | \"bodyType\" | \"body\")[],\n          additionalProperties: false,\n        },\n        ...(output?.example\n          ? {\n              output: {\n                type: \"object\" as const,\n                properties: {\n                  type: {\n                    type: \"string\" as const,\n                  },\n                  example: {\n                    type: \"object\" as const,\n                    ...(output.schema && typeof output.schema === \"object\" ? output.schema : {}),\n                  },\n                },\n                required: [\"type\"] as const,\n              },\n            }\n          : {}),\n      },\n      required: [\"input\"],\n    },\n  };\n}\n\n/**\n * Create a discovery extension for any HTTP method\n *\n * This function helps servers declare how their endpoint should be called,\n * including the expected input parameters/body and output format.\n *\n * @param config - Configuration object for the discovery extension\n * @returns A discovery extension object with both info and schema\n *\n * @example\n * ```typescript\n * // For a GET endpoint with no input\n * const getExtension = declareDiscoveryExtension({\n *   method: \"GET\",\n *   output: {\n *     example: { message: \"Success\", timestamp: \"2024-01-01T00:00:00Z\" }\n *   }\n * });\n *\n * // For a GET endpoint with query params\n * const getWithParams = declareDiscoveryExtension({\n *   method: \"GET\",\n *   input: { query: \"example\" },\n *   inputSchema: {\n *     properties: {\n *       query: { type: \"string\" }\n *     },\n *     required: [\"query\"]\n *   }\n * });\n *\n * // For a POST endpoint with JSON body\n * const postExtension = declareDiscoveryExtension({\n *   method: \"POST\",\n *   input: { name: \"John\", age: 30 },\n *   inputSchema: {\n *     properties: {\n *       name: { type: \"string\" },\n *       age: { type: \"number\" }\n *     },\n *     required: [\"name\"]\n *   },\n *   bodyType: \"json\",\n *   output: {\n *     example: { success: true, id: \"123\" }\n *   }\n * });\n * ```\n */\nexport function declareDiscoveryExtension(\n  config: Omit<DeclareDiscoveryExtensionConfig, \"method\">,\n): Record<string, DiscoveryExtension> {\n  const bodyType = (config as DeclareBodyDiscoveryExtensionConfig).bodyType;\n  const isBodyMethod = bodyType !== undefined;\n\n  const extension = isBodyMethod\n    ? createBodyDiscoveryExtension(config as DeclareBodyDiscoveryExtensionConfig)\n    : createQueryDiscoveryExtension(config as DeclareQueryDiscoveryExtensionConfig);\n\n  return { bazaar: extension as DiscoveryExtension };\n}\n","import type { ResourceServerExtension } from \"@x402/core/types\";\nimport type { HTTPRequestContext } from \"@x402/core/http\";\nimport { BAZAAR } from \"./types\";\n\n/**\n * Type guard to check if context is an HTTP request context.\n *\n * @param ctx - The context to check\n * @returns True if context is an HTTPRequestContext\n */\nfunction isHTTPRequestContext(ctx: unknown): ctx is HTTPRequestContext {\n  return ctx !== null && typeof ctx === \"object\" && \"method\" in ctx && \"adapter\" in ctx;\n}\n\ninterface ExtensionDeclaration {\n  [key: string]: unknown;\n  info?: {\n    [key: string]: unknown;\n    input?: Record<string, unknown>;\n  };\n  schema?: {\n    [key: string]: unknown;\n    properties?: {\n      [key: string]: unknown;\n      input?: {\n        [key: string]: unknown;\n        required?: string[];\n      };\n    };\n  };\n}\n\nexport const bazaarResourceServerExtension: ResourceServerExtension = {\n  key: BAZAAR,\n\n  enrichDeclaration: (declaration, transportContext) => {\n    if (!isHTTPRequestContext(transportContext)) {\n      return declaration;\n    }\n\n    const extension = declaration as ExtensionDeclaration;\n    const method = transportContext.method;\n\n    return {\n      ...extension,\n      info: {\n        ...(extension.info || {}),\n        input: {\n          ...(extension.info?.input || {}),\n          method,\n        },\n      },\n      schema: {\n        ...(extension.schema || {}),\n        properties: {\n          ...(extension.schema?.properties || {}),\n          input: {\n            ...(extension.schema?.properties?.input || {}),\n            required: [\n              ...(extension.schema?.properties?.input?.required || []),\n              ...(!(extension.schema?.properties?.input?.required || []).includes(\"method\")\n                ? [\"method\"]\n                : []),\n            ],\n          },\n        },\n      },\n    };\n  },\n};\n","/**\n * Facilitator functions for validating and extracting Bazaar discovery extensions\n *\n * These functions help facilitators validate extension data against schemas\n * and extract the discovery information for cataloging in the Bazaar.\n *\n * Supports both v2 (extensions in PaymentRequired) and v1 (outputSchema in PaymentRequirements).\n */\n\nimport Ajv from \"ajv/dist/2020\";\nimport type { PaymentPayload, PaymentRequirements, PaymentRequirementsV1 } from \"@x402/core/types\";\nimport type { DiscoveryExtension, DiscoveryInfo } from \"./types\";\nimport { BAZAAR } from \"./types\";\nimport { extractDiscoveryInfoV1 } from \"./v1/facilitator\";\n\n/**\n * Validation result for discovery extensions\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors?: string[];\n}\n\n/**\n * Validates a discovery extension's info against its schema\n *\n * @param extension - The discovery extension containing info and schema\n * @returns Validation result indicating if the info matches the schema\n *\n * @example\n * ```typescript\n * const extension = declareDiscoveryExtension(...);\n * const result = validateDiscoveryExtension(extension);\n *\n * if (result.valid) {\n *   console.log(\"Extension is valid\");\n * } else {\n *   console.error(\"Validation errors:\", result.errors);\n * }\n * ```\n */\nexport function validateDiscoveryExtension(extension: DiscoveryExtension): ValidationResult {\n  try {\n    const ajv = new Ajv({ strict: false, allErrors: true });\n    const validate = ajv.compile(extension.schema);\n\n    // The schema describes the structure of info directly\n    // Schema has properties: { input: {...}, output: {...} }\n    // So we validate extension.info which has { input: {...}, output: {...} }\n    const valid = validate(extension.info);\n\n    if (valid) {\n      return { valid: true };\n    }\n\n    const errors = validate.errors?.map(err => {\n      const path = err.instancePath || \"(root)\";\n      return `${path}: ${err.message}`;\n    }) || [\"Unknown validation error\"];\n\n    return { valid: false, errors };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [\n        `Schema validation failed: ${error instanceof Error ? error.message : String(error)}`,\n      ],\n    };\n  }\n}\n\n/**\n * Extracts the discovery info from payment payload and requirements\n *\n * This function handles both v2 (extensions) and v1 (outputSchema) formats.\n *\n * For v2: Discovery info is in PaymentPayload.extensions (client copied it from PaymentRequired)\n * For v1: Discovery info is in PaymentRequirements.outputSchema\n *\n * V1 data is automatically transformed to v2 DiscoveryInfo format, making smart\n * assumptions about field names (queryParams/query/params for GET, bodyFields/body/data for POST, etc.)\n *\n * @param paymentPayload - The payment payload containing extensions (v2) and version info\n * @param paymentRequirements - The payment requirements (contains outputSchema for v1)\n * @param validate - Whether to validate v2 extensions before extracting (default: true)\n * @returns The discovery info in v2 format if present, or null if not discoverable\n *\n * @example\n * ```typescript\n * // V2 - extensions are in PaymentPayload\n * const info = extractDiscoveryInfo(paymentPayload, paymentRequirements);\n *\n * // V1 - discovery info is in PaymentRequirements.outputSchema\n * const info = extractDiscoveryInfo(paymentPayloadV1, paymentRequirementsV1);\n *\n * if (info) {\n *   // Both v1 and v2 return the same DiscoveryInfo structure\n *   console.log(\"Method:\", info.input.method);\n * }\n * ```\n */\nexport interface DiscoveredResource {\n  resourceUrl: string;\n  method: string;\n  x402Version: number;\n  discoveryInfo: DiscoveryInfo;\n}\n\n/**\n * Extracts discovery information from payment payload and requirements.\n * Combines resource URL, HTTP method, version, and discovery info into a single object.\n *\n * @param paymentPayload - The payment payload containing extensions and resource info\n * @param paymentRequirements - The payment requirements to validate against\n * @param validate - Whether to validate the discovery info against the schema (default: true)\n * @returns Discovered resource info with URL, method, version and discovery data, or null if not found\n */\nexport function extractDiscoveryInfo(\n  paymentPayload: PaymentPayload,\n  paymentRequirements: PaymentRequirements | PaymentRequirementsV1,\n  validate: boolean = true,\n): DiscoveredResource | null {\n  let discoveryInfo: DiscoveryInfo | null = null;\n  let resourceUrl: string;\n\n  if (paymentPayload.x402Version === 2) {\n    resourceUrl = paymentPayload.resource?.url ?? \"\";\n\n    if (paymentPayload.extensions) {\n      const bazaarExtension = paymentPayload.extensions[BAZAAR];\n\n      if (bazaarExtension && typeof bazaarExtension === \"object\") {\n        try {\n          const extension = bazaarExtension as DiscoveryExtension;\n\n          if (validate) {\n            const result = validateDiscoveryExtension(extension);\n            if (!result.valid) {\n              console.warn(\n                `V2 discovery extension validation failed: ${result.errors?.join(\", \")}`,\n              );\n            } else {\n              discoveryInfo = extension.info;\n            }\n          } else {\n            discoveryInfo = extension.info;\n          }\n        } catch (error) {\n          console.warn(`V2 discovery extension extraction failed: ${error}`);\n        }\n      }\n    }\n  } else if (paymentPayload.x402Version === 1) {\n    const requirementsV1 = paymentRequirements as PaymentRequirementsV1;\n    resourceUrl = requirementsV1.resource;\n    discoveryInfo = extractDiscoveryInfoV1(requirementsV1);\n  } else {\n    return null;\n  }\n\n  if (!discoveryInfo) {\n    return null;\n  }\n\n  return {\n    resourceUrl,\n    method: discoveryInfo.input.method,\n    x402Version: paymentPayload.x402Version,\n    discoveryInfo,\n  };\n}\n\n/**\n * Extracts discovery info from a v2 extension directly\n *\n * This is a lower-level function for when you already have the extension object.\n * For general use, prefer the main extractDiscoveryInfo function.\n *\n * @param extension - The discovery extension to extract info from\n * @param validate - Whether to validate before extracting (default: true)\n * @returns The discovery info if valid\n * @throws Error if validation fails and validate is true\n */\nexport function extractDiscoveryInfoFromExtension(\n  extension: DiscoveryExtension,\n  validate: boolean = true,\n): DiscoveryInfo {\n  if (validate) {\n    const result = validateDiscoveryExtension(extension);\n    if (!result.valid) {\n      throw new Error(\n        `Invalid discovery extension: ${result.errors?.join(\", \") || \"Unknown error\"}`,\n      );\n    }\n  }\n\n  return extension.info;\n}\n\n/**\n * Validates and extracts discovery info in one step\n *\n * This is a convenience function that combines validation and extraction,\n * returning both the validation result and the info if valid.\n *\n * @param extension - The discovery extension to validate and extract\n * @returns Object containing validation result and info (if valid)\n *\n * @example\n * ```typescript\n * const extension = declareDiscoveryExtension(...);\n * const { valid, info, errors } = validateAndExtract(extension);\n *\n * if (valid && info) {\n *   // Store info in Bazaar catalog\n * } else {\n *   console.error(\"Validation errors:\", errors);\n * }\n * ```\n */\nexport function validateAndExtract(extension: DiscoveryExtension): {\n  valid: boolean;\n  info?: DiscoveryInfo;\n  errors?: string[];\n} {\n  const result = validateDiscoveryExtension(extension);\n\n  if (result.valid) {\n    return {\n      valid: true,\n      info: extension.info,\n    };\n  }\n\n  return {\n    valid: false,\n    errors: result.errors,\n  };\n}\n","/**\n * V1 Facilitator functions for extracting Bazaar discovery information\n *\n * In v1, discovery information is stored in the `outputSchema` field\n * of PaymentRequirements, which has a different structure than v2.\n *\n * This module transforms v1 data into v2 DiscoveryInfo format.\n */\n\nimport type { PaymentRequirementsV1 } from \"@x402/core/types\";\nimport type { BodyMethods, QueryParamMethods } from \"@x402/core/http\";\nimport type { DiscoveryInfo, QueryDiscoveryInfo, BodyDiscoveryInfo } from \"../types\";\n\n/**\n * Type guard to check if an object has the v1 outputSchema structure\n *\n * @param obj - The object to check\n * @returns True if object has v1 outputSchema structure\n */\nfunction hasV1OutputSchema(\n  obj: unknown,\n): obj is { input: Record<string, unknown>; output?: Record<string, unknown> } {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    \"input\" in obj &&\n    obj.input !== null &&\n    typeof obj.input === \"object\" &&\n    \"type\" in obj.input &&\n    obj.input.type === \"http\" &&\n    \"method\" in obj.input\n  );\n}\n\n/**\n * Checks if a method is a query parameter method\n *\n * @param method - HTTP method string to check\n * @returns True if method is GET, HEAD, or DELETE\n */\nfunction isQueryMethod(method: string): method is QueryParamMethods {\n  const upperMethod = method.toUpperCase();\n  return upperMethod === \"GET\" || upperMethod === \"HEAD\" || upperMethod === \"DELETE\";\n}\n\n/**\n * Checks if a method is a body method\n *\n * @param method - HTTP method string to check\n * @returns True if method is POST, PUT, or PATCH\n */\nfunction isBodyMethod(method: string): method is BodyMethods {\n  const upperMethod = method.toUpperCase();\n  return upperMethod === \"POST\" || upperMethod === \"PUT\" || upperMethod === \"PATCH\";\n}\n\n/**\n * Extracts query parameters from v1 input, making smart assumptions\n * about common field names used in v1\n *\n * @param v1Input - V1 input object from payment requirements\n * @returns Extracted query parameters or undefined\n */\nfunction extractQueryParams(v1Input: Record<string, unknown>): Record<string, unknown> | undefined {\n  // Check various common field names used in v1 (both camelCase and snake_case)\n  if (v1Input.queryParams && typeof v1Input.queryParams === \"object\") {\n    return v1Input.queryParams as Record<string, unknown>;\n  }\n  if (v1Input.query_params && typeof v1Input.query_params === \"object\") {\n    return v1Input.query_params as Record<string, unknown>;\n  }\n  if (v1Input.query && typeof v1Input.query === \"object\") {\n    return v1Input.query as Record<string, unknown>;\n  }\n  if (v1Input.params && typeof v1Input.params === \"object\") {\n    return v1Input.params as Record<string, unknown>;\n  }\n  return undefined;\n}\n\n/**\n * Extracts body information from v1 input, making smart assumptions\n *\n * @param v1Input - V1 input object from payment requirements\n * @returns Object containing body content and bodyType\n */\nfunction extractBodyInfo(v1Input: Record<string, unknown>): {\n  body: Record<string, unknown>;\n  bodyType: \"json\" | \"form-data\" | \"text\";\n} {\n  // Determine body type (check both camelCase and snake_case)\n  let bodyType: \"json\" | \"form-data\" | \"text\" = \"json\";\n  const bodyTypeField = v1Input.bodyType || v1Input.body_type;\n\n  if (bodyTypeField && typeof bodyTypeField === \"string\") {\n    const type = bodyTypeField.toLowerCase();\n    if (type.includes(\"form\") || type.includes(\"multipart\")) {\n      bodyType = \"form-data\";\n    } else if (type.includes(\"text\") || type.includes(\"plain\")) {\n      bodyType = \"text\";\n    } else {\n      bodyType = \"json\";\n    }\n  }\n\n  // Extract body content from various possible fields\n  // Priority order based on observed patterns in real data\n  let body: Record<string, unknown> = {};\n\n  if (v1Input.bodyFields && typeof v1Input.bodyFields === \"object\") {\n    body = v1Input.bodyFields as Record<string, unknown>;\n  } else if (\n    v1Input.body_fields &&\n    v1Input.body_fields !== null &&\n    typeof v1Input.body_fields === \"object\"\n  ) {\n    body = v1Input.body_fields as Record<string, unknown>;\n  } else if (v1Input.bodyParams && typeof v1Input.bodyParams === \"object\") {\n    body = v1Input.bodyParams as Record<string, unknown>;\n  } else if (v1Input.body && typeof v1Input.body === \"object\") {\n    body = v1Input.body as Record<string, unknown>;\n  } else if (v1Input.data && typeof v1Input.data === \"object\") {\n    body = v1Input.data as Record<string, unknown>;\n  } else if (v1Input.properties && typeof v1Input.properties === \"object\") {\n    // Some endpoints have properties directly at the input level\n    body = v1Input.properties as Record<string, unknown>;\n  }\n\n  return { body, bodyType };\n}\n\n/**\n * Extracts discovery info from v1 PaymentRequirements and transforms to v2 format\n *\n * In v1, the discovery information is stored in the `outputSchema` field,\n * which contains both input (endpoint shape) and output (response schema) information.\n *\n * This function makes smart assumptions to normalize v1 data into v2 DiscoveryInfo format:\n * - For GET/HEAD/DELETE: Looks for queryParams, query, or params fields\n * - For POST/PUT/PATCH: Looks for bodyFields, body, or data fields and normalizes bodyType\n * - Extracts optional headers if present\n *\n * @param paymentRequirements - V1 payment requirements\n * @returns Discovery info in v2 format if present and valid, or null if not discoverable\n *\n * @example\n * ```typescript\n * const requirements: PaymentRequirementsV1 = {\n *   scheme: \"exact\",\n *   network: \"eip155:8453\",\n *   maxAmountRequired: \"100000\",\n *   resource: \"https://api.example.com/data\",\n *   description: \"Get data\",\n *   mimeType: \"application/json\",\n *   outputSchema: {\n *     input: {\n *       type: \"http\",\n *       method: \"GET\",\n *       discoverable: true,\n *       queryParams: { query: \"string\" }\n *     },\n *     output: { type: \"object\" }\n *   },\n *   payTo: \"0x...\",\n *   maxTimeoutSeconds: 300,\n *   asset: \"0x...\",\n *   extra: {}\n * };\n *\n * const info = extractDiscoveryInfoV1(requirements);\n * if (info) {\n *   console.log(\"Endpoint method:\", info.input.method);\n * }\n * ```\n */\nexport function extractDiscoveryInfoV1(\n  paymentRequirements: PaymentRequirementsV1,\n): DiscoveryInfo | null {\n  const { outputSchema } = paymentRequirements;\n\n  // Check if outputSchema exists and has the expected structure\n  if (!outputSchema || !hasV1OutputSchema(outputSchema)) {\n    return null;\n  }\n\n  const v1Input = outputSchema.input;\n\n  // Check if the endpoint is marked as discoverable\n  // Default to true if not specified (for backwards compatibility)\n  const isDiscoverable = v1Input.discoverable ?? true;\n\n  if (!isDiscoverable) {\n    return null;\n  }\n\n  const method = typeof v1Input.method === \"string\" ? v1Input.method.toUpperCase() : \"\";\n\n  // Extract headers if present (check both camelCase and snake_case)\n  const headersRaw = v1Input.headerFields || v1Input.header_fields || v1Input.headers;\n  const headers =\n    headersRaw && typeof headersRaw === \"object\"\n      ? (headersRaw as Record<string, string>)\n      : undefined;\n\n  // Extract output example/schema if present\n  const output = outputSchema.output\n    ? {\n        type: \"json\" as const,\n        example: outputSchema.output,\n      }\n    : undefined;\n\n  // Transform based on method type\n  if (isQueryMethod(method)) {\n    // Query parameter method (GET, HEAD, DELETE)\n    const queryParams = extractQueryParams(v1Input);\n\n    const discoveryInfo: QueryDiscoveryInfo = {\n      input: {\n        type: \"http\",\n        method: method as QueryParamMethods,\n        ...(queryParams ? { queryParams } : {}),\n        ...(headers ? { headers } : {}),\n      },\n      ...(output ? { output } : {}),\n    };\n\n    return discoveryInfo;\n  } else if (isBodyMethod(method)) {\n    // Body method (POST, PUT, PATCH)\n    const { body, bodyType } = extractBodyInfo(v1Input);\n    const queryParams = extractQueryParams(v1Input); // Some POST requests also have query params\n\n    const discoveryInfo: BodyDiscoveryInfo = {\n      input: {\n        type: \"http\",\n        method: method as BodyMethods,\n        bodyType,\n        body,\n        ...(queryParams ? { queryParams } : {}),\n        ...(headers ? { headers } : {}),\n      },\n      ...(output ? { output } : {}),\n    };\n\n    return discoveryInfo;\n  }\n\n  // Unsupported method, return null\n  return null;\n}\n\n/**\n * Checks if v1 PaymentRequirements contains discoverable information\n *\n * @param paymentRequirements - V1 payment requirements\n * @returns True if the requirements contain valid discovery info\n *\n * @example\n * ```typescript\n * if (isDiscoverableV1(requirements)) {\n *   const info = extractDiscoveryInfoV1(requirements);\n *   // Catalog info in Bazaar\n * }\n * ```\n */\nexport function isDiscoverableV1(paymentRequirements: PaymentRequirementsV1): boolean {\n  return extractDiscoveryInfoV1(paymentRequirements) !== null;\n}\n\n/**\n * Extracts resource metadata from v1 PaymentRequirements\n *\n * In v1, resource information is embedded directly in the payment requirements\n * rather than in a separate resource object.\n *\n * @param paymentRequirements - V1 payment requirements\n * @returns Resource metadata\n *\n * @example\n * ```typescript\n * const metadata = extractResourceMetadataV1(requirements);\n * console.log(\"Resource URL:\", metadata.url);\n * console.log(\"Description:\", metadata.description);\n * ```\n */\nexport function extractResourceMetadataV1(paymentRequirements: PaymentRequirementsV1): {\n  url: string;\n  description: string;\n  mimeType: string;\n} {\n  return {\n    url: paymentRequirements.resource,\n    description: paymentRequirements.description,\n    mimeType: paymentRequirements.mimeType,\n  };\n}\n","/**\n * Client extensions for querying Bazaar discovery resources\n */\n\nimport { HTTPFacilitatorClient } from \"@x402/core/http\";\nimport { WithExtensions } from \"../types\";\n\n/**\n * Parameters for listing discovery resources.\n * All parameters are optional and used for filtering/pagination.\n */\nexport interface ListDiscoveryResourcesParams {\n  /**\n   * Filter by protocol type (e.g., \"http\", \"mcp\").\n   * Currently, the only supported protocol type is \"http\".\n   */\n  type?: string;\n\n  /**\n   * The number of discovered x402 resources to return per page.\n   */\n  limit?: number;\n\n  /**\n   * The offset of the first discovered x402 resource to return.\n   */\n  offset?: number;\n}\n\n/**\n * A discovered x402 resource from the bazaar.\n */\nexport interface DiscoveryResource {\n  /** The URL of the discovered resource */\n  url: string;\n  /** The protocol type of the resource */\n  type: string;\n  /** Additional metadata about the resource */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Response from listing discovery resources.\n */\nexport interface DiscoveryResourcesResponse {\n  /** The list of discovered resources */\n  resources: DiscoveryResource[];\n  /** Total count of resources matching the query */\n  total?: number;\n  /** The limit used for this query */\n  limit?: number;\n  /** The offset used for this query */\n  offset?: number;\n}\n\n/**\n * Bazaar client extension interface providing discovery query functionality.\n */\nexport interface BazaarClientExtension {\n  discovery: {\n    /**\n     * List x402 discovery resources from the bazaar.\n     *\n     * @param params - Optional filtering and pagination parameters\n     * @returns A promise resolving to the discovery resources response\n     */\n    listResources(params?: ListDiscoveryResourcesParams): Promise<DiscoveryResourcesResponse>;\n  };\n}\n\n/**\n * Extends a facilitator client with Bazaar discovery query functionality.\n * Preserves and merges with any existing extensions from prior chaining.\n *\n * @param client - The facilitator client to extend\n * @returns The client extended with bazaar discovery capabilities\n *\n * @example\n * ```ts\n * // Basic usage\n * const client = withBazaar(new HTTPFacilitatorClient());\n * const resources = await client.extensions.discovery.listResources({ type: \"http\" });\n *\n * // Chaining with other extensions\n * const client = withBazaar(withOtherExtension(new HTTPFacilitatorClient()));\n * await client.extensions.other.someMethod();\n * await client.extensions.discovery.listResources();\n * ```\n */\nexport function withBazaar<T extends HTTPFacilitatorClient>(\n  client: T,\n): WithExtensions<T, BazaarClientExtension> {\n  // Preserve any existing extensions from prior chaining\n  const existingExtensions =\n    (client as T & { extensions?: Record<string, unknown> }).extensions ?? {};\n\n  const extended = client as WithExtensions<T, BazaarClientExtension>;\n\n  extended.extensions = {\n    ...existingExtensions,\n    discovery: {\n      async listResources(\n        params?: ListDiscoveryResourcesParams,\n      ): Promise<DiscoveryResourcesResponse> {\n        let headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n        };\n\n        const authHeaders = await client.createAuthHeaders(\"discovery\");\n        headers = { ...headers, ...authHeaders.headers };\n\n        const queryParams = new URLSearchParams();\n        if (params?.type !== undefined) {\n          queryParams.set(\"type\", params.type);\n        }\n        if (params?.limit !== undefined) {\n          queryParams.set(\"limit\", params.limit.toString());\n        }\n        if (params?.offset !== undefined) {\n          queryParams.set(\"offset\", params.offset.toString());\n        }\n\n        const queryString = queryParams.toString();\n        const endpoint = `${client.url}/discovery/resources${queryString ? `?${queryString}` : \"\"}`;\n\n        const response = await fetch(endpoint, {\n          method: \"GET\",\n          headers,\n        });\n\n        if (!response.ok) {\n          const errorText = await response.text().catch(() => response.statusText);\n          throw new Error(\n            `Facilitator listDiscoveryResources failed (${response.status}): ${errorText}`,\n          );\n        }\n\n        return (await response.json()) as DiscoveryResourcesResponse;\n      },\n    },\n  } as WithExtensions<T, BazaarClientExtension>[\"extensions\"];\n\n  return extended;\n}\n"],"names":["isBodyMethod"],"mappings":"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"}},
    {"offset": {"line": 2319, "column": 0}, "map": {"version":3,"sources":[],"sourcesContent":[],"names":[],"mappings":""}}]
}