/**
 * Setup Script — Creates the Solana Demo Agent
 *
 * This script:
 *   1. Generates a new Solana keypair (the "agent" wallet)
 *   2. Airdrops SOL for transaction fees
 *   3. Creates an Associated Token Account for USDC
 *   4. Prints the addresses needed by the Sepolia side (CCTP mintRecipient)
 *
 * Run: npm run setup
 */

import {
  Connection,
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
} from "@solana/web3.js";
import {
  getOrCreateAssociatedTokenAccount,
  getAssociatedTokenAddress,
} from "@solana/spl-token";
import * as dotenv from "dotenv";
import * as fs from "fs";

dotenv.config();

/** Solana Devnet USDC mint (Circle official) */
const USDC_MINT = new PublicKey(
  process.env.USDC_MINT || "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
);

/** Solana Devnet RPC */
const RPC_URL = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";

/**
 * Convert a Solana PublicKey to a 32-byte hex string for CCTP mintRecipient
 */
function toBytes32Hex(pubkey: PublicKey): string {
  return "0x" + Buffer.from(pubkey.toBytes()).toString("hex");
}

async function main() {
  const connection = new Connection(RPC_URL, "confirmed");

  // ── Step 1: Generate or load agent keypair ─────────────
  let agentKeypair: Keypair;

  if (process.env.AGENT_SECRET_KEY) {
    // Load existing keypair from base58 secret key
    const secretKey = Uint8Array.from(
      JSON.parse(process.env.AGENT_SECRET_KEY)
    );
    agentKeypair = Keypair.fromSecretKey(secretKey);
    console.log("Loaded existing agent keypair");
  } else {
    // Generate a new keypair
    agentKeypair = Keypair.generate();
    console.log("Generated new agent keypair");
  }

  const agentPublicKey = agentKeypair.publicKey;
  console.log(`\nAgent Public Key: ${agentPublicKey.toBase58()}`);

  // ── Step 2: Airdrop SOL for fees (retry with backoff) ──
  console.log("\nRequesting SOL airdrop for transaction fees...");
  let isAirdropSuccessful = false;
  const MAX_AIRDROP_RETRIES = 3;

  for (let attempt = 1; attempt <= MAX_AIRDROP_RETRIES; attempt++) {
    try {
      const airdropSig = await connection.requestAirdrop(
        agentPublicKey,
        1 * LAMPORTS_PER_SOL
      );
      await connection.confirmTransaction(airdropSig, "confirmed");
      console.log("Airdrop successful: 1 SOL");
      isAirdropSuccessful = true;
      break;
    } catch {
      console.warn(`Airdrop attempt ${attempt}/${MAX_AIRDROP_RETRIES} failed.`);
      if (attempt < MAX_AIRDROP_RETRIES) {
        const delay = attempt * 3000;
        console.log(`Retrying in ${delay / 1000}s...`);
        await new Promise((r) => setTimeout(r, delay));
      }
    }
  }

  const solBalance = await connection.getBalance(agentPublicKey);
  console.log(`SOL Balance: ${solBalance / LAMPORTS_PER_SOL} SOL`);

  // ── Step 3: Derive ATA address, create on-chain only if funded ──
  // Always derive the deterministic ATA address (works offline)
  const ataAddress = await getAssociatedTokenAddress(USDC_MINT, agentPublicKey);
  let isAtaCreated = false;

  if (solBalance > 0) {
    // Enough SOL to pay for the ATA creation tx
    console.log("\nCreating USDC Associated Token Account on-chain...");
    try {
      await getOrCreateAssociatedTokenAccount(
        connection,
        agentKeypair,
        USDC_MINT,
        agentPublicKey
      );
      isAtaCreated = true;
      console.log("ATA created on-chain successfully.");
    } catch (err) {
      console.warn("Failed to create ATA on-chain:", (err as Error).message);
    }
  } else {
    console.log("\nSkipping on-chain ATA creation (no SOL for fees).");
    console.log("The ATA address is derived deterministically and is still valid.");
  }

  // ── Step 4: Derive the CCTP mintRecipient (bytes32) ────
  // CCTP expects the token account address as a 32-byte value
  const mintRecipientBytes32 = toBytes32Hex(ataAddress);

  console.log("\n════════════════════════════════════════════");
  console.log("  SOLANA DEMO AGENT — SETUP COMPLETE");
  console.log("════════════════════════════════════════════");
  console.log(`  Agent Wallet:        ${agentPublicKey.toBase58()}`);
  console.log(`  USDC Token Account:  ${ataAddress.toBase58()}`);
  console.log(`  ATA on-chain:        ${isAtaCreated ? "YES" : "NO (create later)"}`);
  console.log(`  CCTP mintRecipient:  ${mintRecipientBytes32}`);
  console.log("════════════════════════════════════════════\n");

  // ── Step 5: Save keypair to .env for future use ────────
  const secretKeyArray = JSON.stringify(Array.from(agentKeypair.secretKey));

  const envContent = `# Generated by setup-agent.ts
SOLANA_RPC_URL=${RPC_URL}
AGENT_SECRET_KEY=${secretKeyArray}
USDC_MINT=${USDC_MINT.toBase58()}
AGENT_PUBLIC_KEY=${agentPublicKey.toBase58()}
USDC_TOKEN_ACCOUNT=${ataAddress.toBase58()}
CCTP_MINT_RECIPIENT=${mintRecipientBytes32}
`;

  fs.writeFileSync(".env", envContent);
  console.log("Saved agent config to .env");

  if (!isAirdropSuccessful) {
    console.log("\n── IMPORTANT ───────────────────────────────");
    console.log("SOL airdrop failed. To complete setup:");
    console.log(`  1. Fund ${agentPublicKey.toBase58()} with SOL on Devnet`);
    console.log("     - Use https://faucet.solana.com or solana airdrop 1");
    console.log("  2. Re-run: npm run setup   (to create the ATA on-chain)");
  }

  console.log("\n── NEXT STEPS ──────────────────────────────");
  console.log("1. Copy the CCTP mintRecipient above");
  console.log("2. On Sepolia, call DemoAgentSepolia.setSolanaRecipient(mintRecipient)");
  console.log("3. Fund DemoAgentSepolia with USDC");
  console.log("4. Call DemoAgentSepolia.sendToSolanaAgent(amount, 5, maxFee)");
  console.log("5. Run: npm run receive   (to poll attestation & claim USDC)");
}

main().catch(console.error);
